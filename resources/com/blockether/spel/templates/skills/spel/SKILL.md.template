---
name: spel
description: "com.blockether.spel package - Clojure wrapper for Playwright 1.58.0. Browser automation, testing, assertions, codegen, CLI. Use when working with browser automation, E2E tests, Playwright API, or visual testing in Clojure."
license: MIT
compatibility: opencode
---

# spel - Clojure Playwright Wrapper

`com.blockether.spel` wraps Playwright Java 1.58.0 with idiomatic Clojure.

## Quick Reference

| Command | Purpose |
|---------|---------|
| `spel --help` | CLI help |
| `spel codegen --help` | Codegen CLI help |
| `spel init-agents --help` | Agent scaffolding help |
| `spel init-agents --loop=opencode` | Scaffold E2E agents for OpenCode (default) |
| `spel init-agents --loop=claude` | Scaffold E2E agents for Claude Code |
| `spel init-agents --loop=vscode` | Scaffold E2E agents for VS Code / Copilot |

---

## Architecture

{{library-api}}

### Error Handling

Uses `com.blockether.anomaly` instead of throwing exceptions:

```clojure
;; All wrapped functions return either a value or an anomaly map
(let [result (page/navigate pg "https://example.com")]
  (if (anomaly/anomaly? result)
    (println "Error:" (:cognitect.anomalies/message result))
    (println "Navigated!")))
```

| Playwright Exception | Anomaly Category | Error Type Keyword |
|---------------------|------------------|-------------------|
| `TimeoutError` | `:cognitect.anomalies/busy` | `:playwright.error/timeout` |
| `TargetClosedError` | `:cognitect.anomalies/interrupted` | `:playwright.error/target-closed` |
| `PlaywrightException` | `:cognitect.anomalies/fault` | `:playwright.error/playwright` |
| Generic `Exception` | `:cognitect.anomalies/fault` | `:playwright.error/unknown` |

### Resource Lifecycle Macros

**Always use macros for cleanup.** They nest naturally:

```clojure
(core/with-playwright [pw]
  (core/with-browser [browser (core/launch-chromium pw {:headless true})]
    (core/with-context [ctx (core/new-context browser)]
      (core/with-page [pg (core/new-page-from-context ctx)]
        (page/navigate pg "https://example.com")
        ;; returns nil on success, throws on failure
        (assert/has-title (assert/assert-that pg) "Example Domain")))))
```

| Macro | Cleans Up |
|-------|-----------|
| `with-playwright` | Playwright instance |
| `with-browser` | Browser instance |
| `with-context` | BrowserContext |
| `with-page` | Page instance |

---

## Common Patterns

### Locating Elements

```clojure
;; By CSS
(page/locator pg "h1")
(page/locator pg "#my-id")

;; By text
(page/get-by-text pg "Click me")

;; By role (requires AriaRole import)
(page/get-by-role pg AriaRole/BUTTON)

;; By role + name filter
(page/get-by-role pg AriaRole/LINK {:name "Learn more"})

;; By role + exact name match
(page/get-by-role pg AriaRole/BUTTON {:name "Submit" :exact true})

;; By label
(page/get-by-label pg "Email")

;; By placeholder
(page/get-by-placeholder pg "Enter email")

;; By test ID
(page/get-by-test-id pg "submit-btn")

;; Sub-locators
(locator/loc-locator (page/locator pg ".card") "h2")
(locator/loc-get-by-text (page/locator pg ".card") "Title")
```

### Strict Mode & Multiple Elements

Playwright uses **strict mode by default** — all locator actions (`click`, `fill`, `text-content`, etc.) require the locator to resolve to **exactly one element**. If multiple elements match, Playwright throws a strict mode violation error.

This is intentional: it prevents accidentally interacting with the wrong element.

**Example error:**

```
Error: strict mode violation: locator("h1") resolved to 4 elements
```

**How to handle multiple matches:**

```clojure
;; WRONG — throws if multiple h1 elements exist
(locator/text-content (page/locator pg "h1"))
(spel/text "h1")  ;; same thing in SCI/eval mode

;; RIGHT — narrow to first element
(locator/text-content (locator/first-element (page/locator pg "h1")))
(spel/text (spel/first "h1"))  ;; SCI/eval equivalent

;; RIGHT — get ALL matching texts as a vector
(locator/all-text-contents (page/locator pg "h1"))
(spel/all-text-contents "h1")  ;; SCI/eval equivalent

;; RIGHT — use a more specific selector
(locator/text-content (page/locator pg "h1.display-1"))
(spel/text "h1.display-1")  ;; SCI/eval equivalent

;; RIGHT — use semantic locators (role + name filter)
(locator/text-content (page/get-by-role pg AriaRole/HEADING {:name "Installation"}))

;; RIGHT — use nth-element for a specific match
(locator/text-content (locator/nth-element (page/locator pg "h1") 0))
(spel/text (spel/nth (spel/$ "h1") 0))  ;; SCI/eval equivalent
```

**Available narrowing functions:**

| Function | Description |
|----------|-------------|
| `locator/first-element` / `spel/first` | First matching element |
| `locator/last-element` / `spel/last` | Last matching element |
| `locator/nth-element` / `spel/nth` | Nth element (0-indexed) |
| `locator/all` / `spel/$$` | All matches as a vector of Locators |
| `locator/all-text-contents` / `spel/all-text-contents` | All texts as a vector |
| `locator/all-inner-texts` / `spel/all-inner-texts` | All inner texts as a vector |
| `locator/count-elements` / `spel/count-of` | Count of matching elements |
| `locator/loc-filter` / `spel/loc-filter` | Filter by text, has-text, or sub-locator |

**Rule of thumb:** If your selector might match multiple elements, either:
1. Make the selector more specific (CSS class, test-id, role + name)
2. Use `first-element` / `spel/first` to explicitly pick the first
3. Use `all-text-contents` / `spel/all-text-contents` to get all values

### Assertions

All assertion functions require `assert-that` first. They return `nil` on success, throw on failure.
In test `it` blocks, ALWAYS wrap with `(expect (nil? ...))`.

```clojure
;; Page assertions (assert-that returns PageAssertions)
(let [pa (assert/assert-that pg)]
  (assert/has-title pa "My Page")
  (assert/has-url pa "https://example.com"))

;; Locator assertions (assert-that returns LocatorAssertions)
(let [la (assert/assert-that (page/locator pg "h1"))]
  (assert/has-text la "Welcome")
  (assert/contains-text la "partial text")
  (assert/is-visible la)
  (assert/is-hidden la)
  (assert/is-checked la)
  (assert/is-enabled la)
  (assert/is-disabled la)
  (assert/is-editable la)
  (assert/is-focused la)
  (assert/is-empty la)
  (assert/is-attached la)
  (assert/is-in-viewport la)
  (assert/has-value la "hello")
  (assert/has-values la ["a" "b"])
  (assert/has-attribute la "href" "https://example.com")
  (assert/has-class la "active")
  (assert/contains-class la "active")
  (assert/has-css la "color" "rgb(0, 0, 0)")
  (assert/has-id la "content")
  (assert/has-role la AriaRole/NAVIGATION)
  (assert/has-count la 5)
  (assert/has-js-property la "dataset.ready" "true")
  (assert/has-accessible-name la "Submit")
  (assert/has-accessible-description la "Enter your email")
  (assert/matches-aria-snapshot la "- navigation"))

;; Locator negation (assert the opposite)
(assert/is-visible (assert/loc-not (assert/assert-that (page/locator pg ".hidden"))))
(assert/is-checked (assert/loc-not (assert/assert-that (page/locator pg "#opt-out"))))

;; Page negation (page-not takes PageAssertions, not Page)
(assert/has-title (assert/page-not (assert/assert-that pg)) "Wrong Title")
(assert/has-url (assert/page-not (assert/assert-that pg)) "https://wrong.com")

;; API response assertion (api-not takes APIResponseAssertions, not APIResponse)
(assert/is-ok (assert/assert-that api-response))
(assert/is-ok (assert/api-not (assert/assert-that api-response)))     ; assert NOT ok

;; In test `it` blocks — ALWAYS wrap with expect:
(expect (nil? (assert/has-text (assert/assert-that (page/locator *page* "h1")) "Welcome")))
(expect (nil? (assert/has-title (assert/assert-that *page*) "My Page")))

;; Timeout override
(assert/set-default-assertion-timeout! 10000)
```

### Events & Signals

```clojure
;; Dialog handling (persistent — fires for every dialog)
(page/on-dialog pg (fn [dialog] (.dismiss dialog)))

;; One-time dialog handler (fires once, then auto-removes)
(page/once-dialog pg (fn [dialog]
  (println "Dialog:" (.message dialog))
  (.accept dialog)))

;; Download handling
(page/on-download pg (fn [dl] (println "Downloaded:" (.suggestedFilename dl))))

;; Popup handling
(page/on-popup pg (fn [popup-pg] (println "Popup URL:" (page/url popup-pg))))

;; Console messages
(page/on-console pg (fn [msg] (println (.type msg) ":" (.text msg))))

;; Page errors
(page/on-page-error pg (fn [err] (println "Page error:" err)))

;; Request/Response events
(page/on-request pg (fn [req] (println "→" (.method req) (.url req))))
(page/on-response pg (fn [resp] (println "←" (.status resp) (.url resp))))

;; waitForPopup / waitForDownload / waitForFileChooser
(let [popup (page/wait-for-popup pg
              #(locator/click (page/locator pg "a")))]
  (page/navigate popup "..."))

(let [dl (page/wait-for-download pg
           #(locator/click (page/locator pg "a.download")))]
  (util/download-save-as! dl "/tmp/file.txt"))

(let [fc (page/wait-for-file-chooser pg
           #(locator/click (page/locator pg "input[type=file]")))]
  (util/file-chooser-set-files! fc "/path/to/file.txt"))
```

### Frame Navigation

```clojure
;; Via FrameLocator (preferred)
(let [fl (frame/frame-locator-obj pg "iframe#main")]
  (locator/click (frame/fl-locator fl "button")))

;; Via Locator.contentFrame()
(let [fl (locator/content-frame (page/locator pg "iframe"))]
  (locator/click (.locator fl "h1")))

;; Nested frames
(let [fl1 (frame/frame-locator-obj pg "iframe.outer")
      fl2 (.frameLocator (frame/fl-locator fl1 "iframe.inner") "iframe.inner")]
  (locator/click (frame/fl-locator fl2 "button")))

;; Frame hierarchy
(let [main-frame (page/main-frame pg)
      children (frame/child-frames main-frame)]
  (doseq [f children]
    (println "Frame:" (frame/frame-name f) "URL:" (frame/frame-url f))))

;; Frame locator methods (same as page)
(let [f (first (page/frames pg))]
  (frame/frame-locator f "button")
  (frame/frame-get-by-text f "Click me")
  (frame/frame-get-by-role f AriaRole/BUTTON)
  (frame/frame-get-by-label f "Email")
  (frame/frame-evaluate f "document.title"))

;; FrameLocator sub-locators
(let [fl (frame/frame-locator-obj pg "iframe")]
  (frame/fl-locator fl "button")
  (frame/fl-get-by-text fl "Submit")
  (frame/fl-get-by-role fl AriaRole/LINK)
  (frame/fl-get-by-label fl "Password")
  (frame/fl-first fl)
  (frame/fl-last fl)
  (frame/fl-nth fl 0))
```

### Utility Functions (util namespace)

```clojure
(require '[com.blockether.spel.util :as util])

;; Dialog handling
(page/on-dialog pg (fn [dialog]
  (println "Type:" (util/dialog-type dialog))       ; "alert", "confirm", "prompt", "beforeunload"
  (println "Message:" (util/dialog-message dialog))
  (println "Default:" (util/dialog-default-value dialog))
  (util/dialog-accept! dialog)                       ; or (util/dialog-accept! dialog "input text")
  ;; (util/dialog-dismiss! dialog)
  ))

;; Download handling
(page/on-download pg (fn [dl]
  (println "URL:" (util/download-url dl))
  (println "File:" (util/download-suggested-filename dl))
  (println "Failure:" (util/download-failure dl))
  (util/download-save-as! dl "/tmp/downloaded.pdf")
  ;; (util/download-cancel! dl)
  ;; (util/download-path dl)
  ;; (util/download-page dl)
  ))

;; Console messages
(page/on-console pg (fn [msg]
  (println (util/console-type msg) ":"       ; "log", "error", "warning", etc.
           (util/console-text msg))
  ;; (util/console-args msg)                 ; vector of JSHandle
  ;; (util/console-location msg)             ; {:url ... :line-number ... :column-number ...}
  ;; (util/console-page msg)
  ))

;; Tracing
(let [tracing (util/context-tracing ctx)]
  (util/tracing-start! tracing {:screenshots true :snapshots true :sources true})
  ;; ... test actions ...
  (util/tracing-stop! tracing {:path "trace.zip"}))

;; Clock manipulation (for time-dependent tests)
(util/clock-install! (util/page-clock pg))
(util/clock-set-fixed-time! (util/page-clock pg) "2024-01-01T00:00:00Z")
(util/clock-set-system-time! (util/page-clock pg) "2024-06-15T12:00:00Z")
(util/clock-fast-forward! (util/page-clock pg) 60000)   ; ms
(util/clock-pause-at! (util/page-clock pg) "2024-01-01")
(util/clock-resume! (util/page-clock pg))

;; CDP (Chrome DevTools Protocol)
;; Requires Chromium browser
(let [session (util/cdp-send pg "Runtime.evaluate" {:expression "1+1"})]
  ;; (util/cdp-on session "Network.requestWillBeSent" handler-fn)
  ;; (util/cdp-detach! session)
  )

;; Video recording
(let [video (page/video pg)]
  (util/video-path video)
  (util/video-save-as! video "/tmp/recording.webm")
  (util/video-delete! video))

;; Workers (Web Workers / Service Workers)
(doseq [w (page/workers pg)]
  (println "Worker URL:" (util/worker-url w))
  (println "Eval:" (util/worker-evaluate w "self.name")))

;; File chooser
(let [fc (page/wait-for-file-chooser pg
           #(locator/click (page/locator pg "input[type=file]")))]
  (util/file-chooser-set-files! fc "/path/to/file.txt")
  ;; (util/file-chooser-page fc)
  ;; (util/file-chooser-element fc)
  ;; (util/file-chooser-is-multiple? fc)
  )

;; Selectors engine
(util/selectors-register! (util/selectors pg) "my-engine" {:script "..."})

;; Web errors
(page/on-page-error pg (fn [err]
  ;; (util/web-error-page err)
  ;; (util/web-error-error err)
  ))
```

### File Input

```clojure
;; Single file
(locator/set-input-files! (page/locator pg "input[type=file]") "/path/to/file.txt")

;; Multiple files
(locator/set-input-files! (page/locator pg "input[type=file]") ["/path/a.txt" "/path/b.txt"])
```

### Browser Launch Options

```clojure
;; Basic headless (default)
(core/launch-chromium pw {:headless true})

;; Headed mode for debugging
(core/launch-chromium pw {:headless false :slow-mo 500})

;; Use Chrome/Edge channel
(core/launch-chromium pw {:channel "chrome"})
(core/launch-chromium pw {:channel "msedge"})

;; Custom browser args
(core/launch-chromium pw {:args ["--disable-gpu" "--no-sandbox"]})

;; Proxy
(core/launch-chromium pw {:proxy {:server "http://proxy:8080"
                                   :username "user"
                                   :password "pass"}})

;; Custom downloads directory
(core/launch-chromium pw {:downloads-path "/tmp/downloads"})

;; All browsers
(core/launch-firefox pw {:headless true})
(core/launch-webkit pw {:headless true})
```

### Browser Context Options

```clojure
;; Custom viewport
(core/new-context browser {:viewport {:width 1920 :height 1080}})

;; Mobile emulation
(core/new-context browser {:viewport {:width 375 :height 812}
                           :is-mobile true
                           :has-touch true
                           :device-scale-factor 3
                           :user-agent "Mozilla/5.0 (iPhone...)"})

;; Locale and timezone
(core/new-context browser {:locale "fr-FR"
                           :timezone-id "Europe/Paris"})

;; Geolocation
(core/new-context browser {:geolocation {:latitude 48.8566 :longitude 2.3522}
                           :permissions ["geolocation"]})

;; Dark mode
(core/new-context browser {:color-scheme :dark})

;; Offline mode
(core/new-context browser {:offline true})

;; Extra HTTP headers
(core/new-context browser {:extra-http-headers {"Authorization" "Bearer token"
                                                 "X-Custom" "value"}})

;; Base URL (for relative navigations)
(core/new-context browser {:base-url "https://example.com"})

;; Storage state (restore cookies + localStorage)
(core/new-context browser {:storage-state "state.json"})

;; Record video
(core/new-context browser {:record-video-dir "/tmp/videos"
                           :record-video-size {:width 1280 :height 720}})

;; Record HAR (HTTP Archive)
(core/new-context browser {:record-har-path "network.har"
                           :record-har-mode :minimal})

;; Ignore HTTPS errors
(core/new-context browser {:ignore-https-errors true})

;; Bypass CSP
(core/new-context browser {:bypass-csp true})

;; Context management
(core/context-grant-permissions! ctx ["clipboard-read" "clipboard-write"])
(core/context-clear-permissions! ctx)
(core/context-cookies ctx)
(core/context-clear-cookies! ctx)
(core/context-set-offline! ctx true)
(core/context-set-extra-http-headers! ctx {"X-Test" "value"})
(core/context-set-default-timeout! ctx 30000)
(core/context-set-default-navigation-timeout! ctx 60000)
```

### Page Routing (network namespace)

```clojure
(require '[com.blockether.spel.network :as net])

;; Block images
(page/route! pg "**/*.{png,jpg,jpeg,gif,svg}" (fn [route]
  (net/route-abort! route)))

;; Mock API response
(page/route! pg "**/api/users" (fn [route]
  (net/route-fulfill! route {:status 200
                             :content-type "application/json"
                             :body "{\"users\":[]}"})))

;; Modify request headers
(page/route! pg "**/*" (fn [route]
  (net/route-continue! route {:headers (merge (net/request-headers (net/route-request route))
                                               {"X-Custom" "injected"})})))

;; Modify response (fetch, then alter)
(page/route! pg "**/api/data" (fn [route]
  (let [resp (net/route-fetch! route)]
    (net/route-fulfill! route {:status 200
                               :body (str (net/response-text resp) " (modified)")}))))

;; Fallback to next handler
(page/route! pg "**/*" (fn [route]
  (if (= "POST" (net/request-method (net/route-request route)))
    (net/route-abort! route)
    (net/route-fallback! route))))

;; Remove route
(page/unroute! pg "**/*.{png,jpg}")

;; Request/Response inspection
(let [req some-request]
  (net/request-url req)            ; "https://example.com/api"
  (net/request-method req)         ; "GET"
  (net/request-headers req)        ; {"accept" "text/html" ...}
  (net/request-post-data req)      ; POST body string or nil
  (net/request-resource-type req)  ; "document", "script", "fetch", etc.
  (net/request-timing req)         ; {:start-time ... :response-end ...}
  (net/request-is-navigation? req) ; true/false
  (net/request-failure req))       ; failure text or nil

(let [resp some-response]
  (net/response-url resp)          ; "https://example.com/api"
  (net/response-status resp)       ; 200
  (net/response-status-text resp)  ; "OK"
  (net/response-ok? resp)          ; true
  (net/response-headers resp)      ; {"content-type" "application/json" ...}
  (net/response-text resp)         ; body string
  (net/response-body resp)         ; byte[]
  (net/response-header-value resp "content-type"))

;; Wait for specific response
(let [resp (page/wait-for-response pg "**/api/users"
             (reify Runnable (run [_]
               (locator/click (page/locator pg "#load-users")))))]
  (println (net/response-status resp)))

;; WebSocket
(let [ws (first (.webSockets pg))]
  (net/ws-url ws)
  (net/ws-is-closed? ws)
  (net/ws-on-message ws (fn [frame]
    (println "WS msg:" (net/wsf-text frame))))
  (net/ws-on-close ws (fn [_ws] (println "WS closed")))
  (net/ws-on-error ws (fn [err] (println "WS error:" err))))
```

### Waiting

```clojure
;; Wait for element to appear
(page/wait-for-selector pg ".loaded")
(page/wait-for-selector pg ".modal" {:state :visible :timeout 10000})
;; :state values — :attached :detached :visible :hidden

;; Wait for URL change
(page/wait-for-url pg "https://example.com/dashboard")
(page/wait-for-url pg #".*dashboard.*")               ; regex
(page/wait-for-url pg #(clojure.string/includes? % "dash"))  ; predicate

;; Wait for JS function to return truthy
(page/wait-for-function pg "() => document.querySelector('.ready')")

;; Wait for load state
(page/wait-for-load-state pg)                    ; default: load
(page/wait-for-load-state pg :domcontentloaded)
(page/wait-for-load-state pg :networkidle)

;; Wait for timeout (sleep)
(page/wait-for-timeout pg 1000)

;; Locator wait-for (wait for locator to satisfy condition)
(locator/wait-for (page/locator pg ".spinner") {:state :hidden})
(locator/wait-for (page/locator pg ".content") {:state :visible :timeout 5000})
```

### Page Utilities

```clojure
;; Set HTML content directly (useful for tests)
(page/set-content! pg "<h1>Hello</h1><p>World</p>")

;; Emulate media
(page/emulate-media! pg {:media :screen})              ; or :print
(page/emulate-media! pg {:color-scheme :dark})          ; or :light :no-preference
(page/emulate-media! pg {:media :print :color-scheme :dark})

;; Set viewport
(page/set-viewport-size! pg 1024 768)

;; Add script/style tags
(page/add-script-tag pg {:url "https://cdn.example.com/lib.js"})
(page/add-script-tag pg {:content "window.myVar = 42;"})
(page/add-script-tag pg {:path "/path/to/local.js"})

(page/add-style-tag pg {:content "body { background: red; }"})
(page/add-style-tag pg {:url "https://cdn.example.com/style.css"})

;; Expose Clojure function to JavaScript
(page/expose-function! pg "clojureAdd" (fn [a b] (+ a b)))
;; In JS: await window.clojureAdd(1, 2)  => 3

;; Expose binding (receives BindingSource as first arg)
(page/expose-binding! pg "getPageInfo" (fn [source]
  (str "Frame: " (.frame source))))

;; Extra HTTP headers for this page
(page/set-extra-http-headers! pg {"Authorization" "Bearer token"})

;; Bring page to front (activate tab)
(page/bring-to-front pg)
```

### Advanced Locator Actions

```clojure
;; Drag and drop
(locator/drag-to (page/locator pg "#source") (page/locator pg "#target"))

;; Dispatch custom DOM event
(locator/dispatch-event (page/locator pg "#el") "click")
(locator/dispatch-event (page/locator pg "#el") "dragstart" {:dataTransfer {}})

;; Scroll element into view
(locator/scroll-into-view (page/locator pg "#offscreen"))

;; Tap (touch) element
(locator/tap-element (page/locator pg "#button"))

;; Evaluate JavaScript on element
(locator/evaluate-locator (page/locator pg "#el") "el => el.dataset.value")
(locator/evaluate-all (page/locator pg ".items") "els => els.length")

;; Take screenshot of specific element
(locator/locator-screenshot (page/locator pg ".card"))
(locator/locator-screenshot (page/locator pg ".card") {:path "card.png"})

;; Highlight element (visual debugging)
(locator/highlight (page/locator pg "#important"))

;; Get/set attributes
(locator/get-attribute (page/locator pg "a") "href")

;; Select dropdown option
(locator/select-option (page/locator pg "select") "value")
(locator/select-option (page/locator pg "select") ["val1" "val2"])  ; multi-select

;; Check/uncheck
(locator/check (page/locator pg "#checkbox"))
(locator/uncheck (page/locator pg "#checkbox"))

;; Hover
(locator/hover (page/locator pg ".tooltip-trigger"))
```

### Input Devices (input namespace)

```clojure
(require '[com.blockether.spel.input :as input])

;; Keyboard
(let [kb (page/page-keyboard pg)]
  (input/key-press kb "Enter")
  (input/key-press kb "Control+a")
  (input/key-press kb "Shift+ArrowRight" {:delay 100})
  (input/key-type kb "Hello World" {:delay 50})
  (input/key-down kb "Shift")
  (input/key-up kb "Shift")
  (input/key-insert-text kb "直接挿入"))  ; insert without key events

;; Mouse
(let [mouse (page/page-mouse pg)]
  (input/mouse-click mouse 100 200)
  (input/mouse-dblclick mouse 100 200)
  (input/mouse-move mouse 300 400 {:steps 10})
  (input/mouse-down mouse)
  (input/mouse-up mouse)
  (input/mouse-wheel mouse 0 100))    ; scroll down 100px

;; Touchscreen
(let [ts (page/page-touchscreen pg)]
  (input/touchscreen-tap ts 100 200))
```

### API Testing (api namespace)

```clojure
(require '[com.blockether.spel.api :as api])

;; Single API context
(api/with-api-context [ctx (api/new-api-context (api/api-request pw)
                             {:base-url "https://api.example.com"
                              :extra-http-headers {"Authorization" "Bearer token"}})]
  (let [resp (api/api-get ctx "/users")]
    (println (api/api-response-status resp))     ; 200
    (println (api/api-response-text resp))))      ; JSON body

;; Multiple API contexts
(api/with-api-contexts
  [users   (api/new-api-context (api/api-request pw) {:base-url "https://users.example.com"})
   billing (api/new-api-context (api/api-request pw) {:base-url "https://billing.example.com"})]
  (api/api-get users "/me")
  (api/api-get billing "/invoices"))

;; JSON encoding — MUST bind *json-encoder* before using :json option
(require '[cheshire.core :as json])
(binding [api/*json-encoder* json/generate-string]
  (api/api-post ctx "/users" {:json {:name "Alice" :age 30}}))
;; Or set globally:
(alter-var-root #'api/*json-encoder* (constantly json/generate-string))
;; Using :json WITHOUT binding *json-encoder* will throw!

;; HTTP methods
(api/api-get ctx "/users" {:params {:page 1}})
(api/api-post ctx "/users" {:data "{\"name\":\"Alice\"}" :headers {"Content-Type" "application/json"}})
(api/api-put ctx "/users/1" {:data "{\"name\":\"Bob\"}"})
(api/api-patch ctx "/users/1" {:data "{\"name\":\"Charlie\"}"})
(api/api-delete ctx "/users/1")
(api/api-head ctx "/health")
(api/api-fetch ctx "/resource" {:method "OPTIONS"})

;; Form data
(let [fd (api/form-data)]
  (api/fd-set fd "name" "Alice")
  (api/fd-append fd "tag" "clojure")
  (api/api-post ctx "/submit" {:form fd}))
;; Or from map:
(api/api-post ctx "/submit" {:form (api/map->form-data {:name "Alice" :email "a@b.c"})})

;; Response inspection
(let [resp (api/api-get ctx "/users")]
  (api/api-response-status resp)         ; 200
  (api/api-response-status-text resp)    ; "OK"
  (api/api-response-url resp)
  (api/api-response-ok? resp)            ; true
  (api/api-response-headers resp)        ; {"content-type" "..."}
  (api/api-response-text resp)           ; body string
  (api/api-response-body resp)           ; byte[]
  (api/api-response->map resp))          ; {:status 200 :ok? true :headers {...} :body "..."}

;; Hooks (request/response interceptors)
(api/with-hooks
  {:on-request  (fn [method url opts] (println "→" method url) opts)
   :on-response (fn [method url resp] (println "←" method (api/api-response-status resp)) resp)}
  (api/api-get ctx "/users"))

;; Retry with backoff
(api/retry #(api/api-get ctx "/flaky")
  {:max-attempts 5 :delay-ms 1000 :backoff :linear
   :retry-when (fn [r] (= 429 (:status (api/api-response->map r))))})
;; Or with macro:
(api/with-retry {:max-attempts 3 :delay-ms 200}
  (api/api-post ctx "/endpoint" {:json {:action "process"}}))

;; Standalone request (no context setup needed)
(api/request! pw :get "https://api.example.com/health")
(api/request! pw :post "https://api.example.com/users"
  {:data "{\"name\":\"Alice\"}" :headers {"Content-Type" "application/json"}})
```

### Allure Test Reporting (allure namespace)

```clojure
(require '[com.blockether.spel.allure :as allure])

;; Labels (call inside test body)
(allure/epic "E2E Testing")
(allure/feature "Authentication")
(allure/story "Login Flow")
(allure/severity :critical)          ; :blocker :critical :normal :minor :trivial
(allure/owner "team@example.com")
(allure/tag "smoke")
(allure/description "Tests the complete login flow")
(allure/link "Docs" "https://example.com/docs")
(allure/issue "BUG-123" "https://github.com/example/issues/123")
(allure/tms "TC-456" "https://tms.example.com/456")
(allure/parameter "browser" "chromium")

;; Steps
(allure/step "Navigate to login page"
  (page/navigate pg "https://example.com/login"))

;; Nested steps
(allure/step "Login flow"
  (allure/step "Enter credentials"
    (locator/fill (page/locator pg "#user") "admin")
    (locator/fill (page/locator pg "#pass") "secret"))
  (allure/step "Submit"
    (locator/click (page/locator pg "#submit"))))

;; UI step (auto-captures before/after screenshots, requires *page* binding)
(allure/ui-step "Fill login form"
  (locator/fill username-input "admin")
  (locator/fill password-input "secret")
  (locator/click submit-btn))

;; API step (auto-attaches response details: status, headers, body)
(allure/api-step "Create user"
  (api/api-post ctx "/users" {:json {:name "Alice" :age 30}}))

;; Attachments
(allure/attach "Request Body" "{\"key\":\"value\"}" "application/json")
(allure/attach-bytes "Screenshot" (page/screenshot pg) "image/png")
(allure/screenshot pg "After navigation")        ; convenience: attach PNG screenshot
(allure/attach-api-response! resp)               ; attach full API response
```

### Allure Reporter Pipeline

The built-in reporter generates the full HTML report automatically using Allure 3 (pinned to 3.1.0 via npx):

1. Writes Allure JSON results to `allure-results/` (Allure 2+ compatible format)
2. Resolves Allure 3 CLI via `npx allure@3.1.0` (no manual install needed)
3. Generates HTML report to `allure-report/` using `allure awesome`
4. Embeds a local Playwright trace viewer (no dependency on `trace.playwright.dev`)
5. Patches report JS to load traces from `./trace-viewer/` and pre-registers the Service Worker for instant loading
6. Manages run history via `.allure-history.jsonl` (Allure 3 JSONL mechanism, configurable limit)

### Allure Configuration

| Property | Env Var | Default | Description |
|----------|---------|---------|-------------|
| `lazytest.allure.output` | `LAZYTEST_ALLURE_OUTPUT` | `allure-results` | Results output directory |
| `lazytest.allure.report` | `LAZYTEST_ALLURE_REPORT` | `allure-report` | HTML report directory |
| `lazytest.allure.history-limit` | `LAZYTEST_ALLURE_HISTORY_LIMIT` | `10` | Max builds retained in history |
| `lazytest.allure.report-name` | `LAZYTEST_ALLURE_REPORT_NAME` | _(auto: "spel vX.Y.Z")_ | Report title (shown in header and history). Auto-includes version when not set. |
| `lazytest.allure.version` | `LAZYTEST_ALLURE_VERSION` | _(SPEL_VERSION)_ | Project version shown in build history and environment. Falls back to `SPEL_VERSION` resource. |
| `lazytest.allure.logo` | `LAZYTEST_ALLURE_LOGO` | _(none)_ | Path to logo image for report header |

**Version in build listings**: When `lazytest.allure.version` is set (or `SPEL_VERSION` is on the classpath), each build in the Allure history is tagged with the version. The report name auto-generates as `"spel vX.Y.Z"` unless overridden by `report-name`. The version also appears in `environment.properties` as `project.version` and `spel.version`.

```bash
# Run tests + generate Allure HTML report (allure-results/ + allure-report/)
clojure -M:test --output nested --output com.blockether.spel.allure-reporter/allure

# Serve the generated report in browser (port 9999)
npx http-server allure-report -o -p 9999

# Tag build with custom version (overrides SPEL_VERSION)
clojure -J-Dlazytest.allure.version=1.2.3 -M:test \
  --output nested --output com.blockether.spel.allure-reporter/allure

# Keep last 20 builds in history
LAZYTEST_ALLURE_HISTORY_LIMIT=20 clojure -M:test \
  --output nested --output com.blockether.spel.allure-reporter/allure
```

> **Note**: The report MUST be served via HTTP (not `file://`) because the embedded Playwright trace viewer uses a Service Worker.

### Trace Viewer Integration

When using test fixtures (`with-page` / `with-traced-page`) with Allure reporter active, Playwright tracing is automatically enabled:

- Screenshots captured on every action
- DOM snapshots included
- Network activity recorded
- Sources captured
- HAR file generated

Trace and HAR files are automatically attached to test results (MIME type `application/vnd.allure.playwright-trace`) and viewable directly in the Allure report via an embedded local trace viewer — no external service dependency.

#### Source Mapping in Trace Viewer

All step macros (`step`, `ui-step`, `api-step`, `describe`, `it`, `expect`) automatically capture the source file and line number at macro expansion time and pass them to `Tracing.group()` via `GroupOptions.setLocation()`. This means clicking a step in the Trace Viewer **Source** tab shows the actual test code where the step was written — not the allure.clj macro internals.

Source path resolution uses the `PLAYWRIGHT_JAVA_SRC` environment variable (auto-set to `src:test:dev` by `core/create`) to resolve classpath-relative paths (e.g. `com/blockether/spel/smoke_test.clj`) to project-relative paths (e.g. `test/com/blockether/spel/smoke_test.clj`) that match the trace's captured sources.

For custom source directories, set `PLAYWRIGHT_JAVA_SRC` before creating the Playwright instance:

```bash
PLAYWRIGHT_JAVA_SRC="src:test:test-e2e:dev" clojure -M:test ...
```

### JUnit XML Reporter

Produces JUnit XML output fully compliant with the Apache Ant JUnit schema — compatible with GitHub Actions, Jenkins, GitLab CI, and any CI system that consumes JUnit XML.

```bash
# Run with JUnit reporter (silent during run, writes XML on completion)
clojure -M:test --output com.blockether.spel.junit-reporter/junit

# Combine with visual output (recommended)
clojure -M:test --output nested --output com.blockether.spel.junit-reporter/junit

# Combine with both Allure and JUnit
clojure -M:test --output nested \
  --output com.blockether.spel.allure-reporter/allure \
  --output com.blockether.spel.junit-reporter/junit
```

#### JUnit Configuration

| Property | Env Var | Default | Description |
|----------|---------|---------|-------------|
| `lazytest.junit.output` | `LAZYTEST_JUNIT_OUTPUT` | `test-results/junit.xml` | Output file path |

```bash
# Custom output path
clojure -J-Dlazytest.junit.output=reports/results.xml -M:test \
  --output nested --output com.blockether.spel.junit-reporter/junit

# Or via env var
LAZYTEST_JUNIT_OUTPUT=reports/results.xml clojure -M:test \
  --output nested --output com.blockether.spel.junit-reporter/junit
```

#### JUnit XML Features

- `<testsuites>` root with aggregate counts (tests, failures, errors, skipped, time)
- `<testsuite>` per namespace with timestamp, hostname, package, id
- `<testcase>` with classname (namespace), name (describe > it path), time, file
- `<failure>` vs `<error>` distinction (assertion failure vs unexpected exception)
- `<skipped>` support for pending tests
- `<properties>` with environment metadata (JVM version, OS, Clojure version)
- `<system-out>` / `<system-err>` — per-test captured stdout/stderr output

---

## Codegen - Record & Transform

Record browser sessions and transform to idiomatic Clojure.

### Workflow

```bash
# 1. Record browser session (opens interactive Playwright Codegen recorder)
# Defaults to --target=jsonl for the spel transform pipeline
spel codegen record -o recording.jsonl https://example.com

# 2. Transform JSONL to Clojure test
spel codegen recording.jsonl > my_test.clj
spel codegen --format=script recording.jsonl
spel codegen --format=body recording.jsonl
```

### Formats

| Format | Output |
|--------|--------|
| `:test` (default) | Full Lazytest file with `defdescribe`/`it`, `with-playwright`/`with-browser`/`with-context`/`with-traced-page` |
| `:script` | Standalone script with `require`/`import` + `with-playwright` chain |
| `:body` | Just action lines for pasting into existing code |

### Supported Actions

| Action | Codegen Output |
|--------|---------------|
| `navigate` | `(page/navigate pg "url")` |
| `click` | `(locator/click loc)` with modifiers, button, position |
| `click` (dblclick) | `(locator/dblclick loc)` when clickCount=2 |
| `click` (N>2) | `(locator/click loc {:click-count N})` |
| `fill` | `(locator/fill loc "text")` |
| `press` | `(locator/press loc "key")` with modifier combos |
| `hover` | `(locator/hover loc)` with optional position |
| `check`/`uncheck` | `(locator/check loc)` / `(locator/uncheck loc)` |
| `select` | `(locator/select-option loc "value")` |
| `setInputFiles` | `(locator/set-input-files! loc "path")` or vector |
| `assertText` | `(assert/has-text (assert/assert-that loc) "text")` |
| `assertChecked` | `(assert/is-checked (assert/assert-that loc))` |
| `assertVisible` | `(assert/is-visible (assert/assert-that loc))` |
| `assertValue` | `(assert/has-value (assert/assert-that loc) "val")` |
| `assertSnapshot` | `(assert/matches-aria-snapshot (assert/assert-that loc) "snapshot")` |

### Signal Handling

| Signal | Codegen Pattern |
|--------|----------------|
| `dialog` | `(page/on-dialog pg (fn [dialog] (.dismiss dialog)))` BEFORE action |
| `popup` | `(let [popup-pg (page/wait-for-popup pg #(action))] ...)` AROUND action |
| `download` | `(let [download (page/wait-for-download pg #(action))] ...)` AROUND action |

### Frame Navigation in Codegen

`framePath` array generates chained `.contentFrame()` calls:

```clojure
;; framePath: ["iframe.outer", "iframe.inner"]
(let [fl0 (.contentFrame (page/locator pg "iframe.outer"))
      fl1 (.contentFrame (.locator fl0 "iframe.inner"))]
  (locator/click (.locator fl1 "button")))
```

### Hard Errors

Codegen dies immediately on:
- Unknown action types
- Unknown signal types
- Unrecognized locator formats
- Missing locator/selector data

In CLI mode: prints full action data + `System/exit 1`.
In library mode: throws `ex-info` with `:codegen/error` and `:codegen/action`.

---

## CLI

Wraps Playwright CLI commands via the `spel` native binary.

> **Note**: `spel install` delegates to `com.microsoft.playwright.CLI`, which is a thin shim that spawns the same Node.js Playwright CLI that `npx playwright` uses. The driver version is pinned to the Playwright Java dependency (1.58.0), so browser versions always match.

```bash
spel install                        # Install browsers (Chromium by default)
spel install --with-deps chromium   # Install with system dependencies
spel codegen URL                    # Record interactions
spel open URL                       # Open browser
spel screenshot URL                 # Take screenshot
```

#### Corporate Proxy / Custom CA Certificates

Behind a corporate SSL-inspecting proxy, `spel install` may fail with "PKIX path building failed". Use these env vars to add corporate CA certs:

| Env Var | Format | On missing file | Description |
|---------|--------|----------------|-------------|
| `SPEL_CA_BUNDLE` | PEM file | Error | Extra CA certs (merged with defaults) |
| `NODE_EXTRA_CA_CERTS` | PEM file | Warning, skips | Shared with Node.js subprocess |
| `SPEL_TRUSTSTORE` | JKS/PKCS12 | Error | Truststore (merged with defaults) |
| `SPEL_TRUSTSTORE_TYPE` | String | — | Default: JKS |
| `SPEL_TRUSTSTORE_PASSWORD` | String | — | Default: empty |

```bash
# Simplest — PEM file with corporate CA
export SPEL_CA_BUNDLE=/path/to/corporate-ca.pem
spel install --with-deps

# Or reuse Node.js var — covers both driver + browser downloads
export NODE_EXTRA_CA_CERTS=/path/to/corporate-ca.pem
spel install --with-deps
```

All options merge with built-in defaults — public CDN certs continue to work.

### Playwright Tools

Launch Playwright's built-in visual tools directly from `spel`:

```bash
# Inspector — opens a headed browser with the Playwright Inspector panel.
# Use to explore the page, pick locators, and record actions interactively.
spel inspector                                      # Open Inspector (blank page)
spel inspector https://example.com                  # Open Inspector on URL
spel inspector -b firefox https://example.com       # Use Firefox
spel inspector --device "iPhone 14" https://example.com  # Emulate device

# Trace Viewer — opens the Playwright Trace Viewer to inspect recorded traces.
# Traces are created via `spel trace start` / `spel trace stop` or automatically
# by test fixtures with Allure reporter active.
spel show-trace                     # Open Trace Viewer (blank)
spel show-trace trace.zip           # Open specific trace file
spel show-trace --port 8080 trace.zip  # Serve on specific port
```

**Inspector options** (all Playwright `open` flags are supported):

| Flag | Description |
|------|-------------|
| `-b, --browser <type>` | Browser engine: `cr`/`chromium`, `ff`/`firefox`, `wk`/`webkit` (default: chromium) |
| `--channel <channel>` | Chromium channel: `chrome`, `chrome-beta`, `msedge-dev`, etc. |
| `--device <name>` | Emulate device (e.g. `"iPhone 14"`, `"Pixel 7"`) |
| `--color-scheme <scheme>` | `light` or `dark` |
| `--geolocation <lat,lng>` | Geolocation coordinates |
| `--lang <locale>` | Language locale (e.g. `en-GB`) |
| `--timezone <tz>` | Timezone (e.g. `Europe/Rome`) |
| `--viewport-size <w,h>` | Viewport size (e.g. `1280,720`) |
| `--user-agent <ua>` | Custom user agent |
| `--proxy-server <url>` | Proxy server |
| `--ignore-https-errors` | Ignore HTTPS certificate errors |
| `--load-storage <file>` | Load saved storage state |
| `--save-storage <file>` | Save storage state on exit |
| `--save-har <file>` | Save HAR file on exit |
| `--timeout <ms>` | Action timeout in ms |

---

## Page Exploration (spel)

The `spel` CLI provides comprehensive page exploration capabilities without writing code.

### Basic Exploration Workflow

```bash
# 1. Navigate to a page
spel open https://example.com

# 2. Get accessibility snapshot with numbered refs (e1, e2, etc.)
spel snapshot

# 3. Take a screenshot for visual reference
spel screenshot page.png
```

### Snapshot Command

The primary exploration tool - returns an ARIA accessibility tree with numbered refs:

```bash
spel snapshot                           # Full accessibility tree
spel snapshot -i                        # Interactive elements only
spel snapshot -i -c                     # Compact format
spel snapshot -i -c -d 3               # Limit depth to 3 levels
spel snapshot -i -C                     # Include cursor/pointer elements
spel snapshot -s "#main"               # Scoped to CSS selector
```

**Output format:**
```
- heading "Example Domain" [@e1] [level=1]
- link "More information..." [@e2]
- button "Submit" [@e3]
```

### Get Page Information

```bash
spel get url                           # Current URL
spel get title                         # Page title
spel get text @e1                      # Text content of ref e1
spel get html @e1                      # Inner HTML
spel get value @e2                     # Input value
spel get attr @e1 href                 # Attribute value
spel get count ".items"               # Count matching elements
spel get box @e1                       # Bounding box {x, y, width, height}
```

### Check Element State

```bash
spel is visible @e1                    # Check visibility
spel is enabled @e1                    # Check if enabled
spel is checked @e3                    # Check checkbox state
```

### Find Elements (Semantic Locators)

Find and interact in one command:

```bash
# Find by ARIA role
spel find role button click
spel find role button click --name "Submit"

# Find by text content
spel find text "Login" click

# Find by label
spel find label "Email" fill "test@example.com"

# Position-based
spel find first ".item" click
spel find last ".item" click
spel find nth 2 ".item" click
```

### Visual Exploration

```bash
spel screenshot                        # Screenshot to stdout (base64)
spel screenshot shot.png              # Save to file
spel screenshot -f full.png           # Full page screenshot
spel pdf page.pdf                     # Save as PDF (Chromium only)
spel highlight @e1                    # Highlight element visually
```

### Network Exploration

```bash
spel network requests                  # View all captured requests
spel network requests --type fetch    # Filter by type (document, script, fetch, image, etc.)
spel network requests --method POST   # Filter by HTTP method
spel network requests --status 2      # Filter by status prefix (2=2xx, 4=4xx)
spel network requests --filter "/api" # Filter by URL regex
spel network clear                    # Clear captured requests
```

### JavaScript Evaluation

```bash
# Run JavaScript
spel eval "document.title"
spel eval "document.querySelector('h1').textContent"

# Base64-encoded result
spel eval "JSON.stringify([...document.querySelectorAll('a')].map(a => ({text: a.textContent, href: a.href})))" -b
```

### Console & Errors

Console messages and page errors are auto-captured from the moment a page opens. No `start` command needed.

```bash
spel console                           # View captured console messages
spel console clear                     # Clear captured messages

spel errors                            # View captured page errors
spel errors clear                      # Clear captured errors
```

### Complete Exploration Example

```bash
# Open page
spel open https://example.com

# Get initial snapshot
spel snapshot -i

# Take screenshot
spel screenshot initial.png

# Get page info
spel get title
spel get url

# Check specific element
spel get text @e2
spel is visible @e3

# Interact and re-snapshot
spel click @e2
spel snapshot -i

# View network activity
spel network requests

# Close browser when done
spel close
```

---

## Agent Scaffolding (init-agents)

Scaffolds agent definitions for Playwright E2E testing into any consuming project. Equivalent to Playwright's `npx playwright init-agents --loop=<target>` but for the Clojure/Lazytest/spel stack.

Supports three editor targets via `--loop`:

```bash
spel init-agents                      # OpenCode (default)
spel init-agents --loop=claude        # Claude Code
spel init-agents --loop=vscode        # VS Code / Copilot
```

### CLI Options

| Flag | Default | Purpose |
|------|---------|---------|
| `--loop TARGET` | `opencode` | Agent format: `opencode`, `claude`, `vscode` |
| `--ns NS` | dir name | Base namespace for generated tests (e.g. `my-app` → `my-app.e2e.seed-test`) |
| `--dry-run` | - | Preview files without writing |
| `--force` | - | Overwrite existing files |
| `--test-dir DIR` | `test/e2e` | E2E test output directory |
| `--specs-dir DIR` | `test-e2e/specs` | Test plans directory (colocated with tests) |
| `-h, --help` | - | Show help |

### Generated Files by Target

**`--loop=opencode`** (default):

| File | Purpose |
|------|---------|
| `.opencode/agents/spel-test-planner.md` | Explores app, writes structured test plans to `test-e2e/specs/` |
| `.opencode/agents/spel-test-generator.md` | Reads test plans, generates Clojure Lazytest code using spel |
| `.opencode/agents/spel-test-healer.md` | Runs failing tests, diagnoses issues, applies fixes |
| `.opencode/prompts/spel-test-workflow.md` | Orchestrator prompt: plan → generate → heal cycle |
| `.opencode/skills/spel/SKILL.md` | Copy of this API reference skill (so agents work out-of-the-box) |

**`--loop=claude`**:

| File | Purpose |
|------|---------|
| `.claude/agents/spel-test-planner.md` | Same as OpenCode but with Claude Code frontmatter |
| `.claude/agents/spel-test-generator.md` | Same as OpenCode but with Claude Code frontmatter |
| `.claude/agents/spel-test-healer.md` | Same as OpenCode but with Claude Code frontmatter |
| `.claude/prompts/spel-test-workflow.md` | Orchestrator prompt |
| `.claude/docs/spel/SKILL.md` | API reference |

**`--loop=vscode`**:

| File | Purpose |
|------|---------|
| `.github/agents/spel-test-planner.agent.md` | Same as OpenCode but with VS Code / Copilot frontmatter |
| `.github/agents/spel-test-generator.agent.md` | Same as OpenCode but with VS Code / Copilot frontmatter |
| `.github/agents/spel-test-healer.agent.md` | Same as OpenCode but with VS Code / Copilot frontmatter |
| `.github/prompts/spel-test-workflow.md` | Orchestrator prompt |
| `.github/docs/spel/SKILL.md` | API reference |

**All targets** also generate:

| File | Purpose |
|------|---------|
| `test-e2e/specs/README.md` | Test plans directory README (colocated with tests) |
| `test-e2e/<ns>/e2e/seed_test.clj` | Seed test with `{{ns}}` replaced by `--ns` value (or directory name) |

### Agent Workflow

Three subagents work together in a plan → generate → heal loop:

1. **@spel-test-planner** — Explores the app using `spel` CLI commands (e.g., `spel snapshot`) and inline Clojure scripts with spel. Catalogs pages/flows, writes structured test plans as markdown files in `test-e2e/specs/`. Uses `spel` skill for API reference.

2. **@spel-test-generator** — Reads test plans from `test-e2e/specs/`, generates Clojure Lazytest test files using `spel` test fixtures (`{:context [with-playwright with-browser with-traced-page]}`) and `*page*` dynamic var. Verifies selectors with inline scripts and runs tests to confirm. Outputs to `test-e2e/`.

3. **@spel-test-healer** — Runs tests via `clojure -M:test`, captures failures, uses `spel` CLI commands and inline scripts for investigation, diagnoses root causes (stale selectors, timing, missing setup), and applies targeted fixes. Loops until green.

**Orchestration**: Use the `spel-test-workflow` prompt to trigger the full cycle, or invoke individual agents with `@agent-name`.

**No external dependencies**: All agents use spel directly — no Agent Browser or external MCP tools needed.

### Template System

Templates use `.clj.template` extension (not `.clj`) to avoid clojure-lsp parsing `{{ns}}` placeholders as Clojure code. The `process-template` function replaces `{{ns}}` with the `--ns` value (or falls back to the consuming project's directory name).

---

## Testing Conventions

- Framework: **Lazytest** (`defdescribe`, `describe`, `it`, `expect`)
- Fixtures: **Lazytest `:context`** with shared `around` hooks from `test-fixtures`
- Assertions: **Exact string matching** (NEVER substring unless explicitly `contains-text`)
- Import: `[com.microsoft.playwright.options AriaRole]` for role-based locators (all 16 Playwright enums are auto-available in `--eval` mode — see the Enums table in SCI Eval API Reference below)
- Integration tests: Live against `example.com`

### Running Tests (Lazytest CLI)

```bash
# Run entire test suite
clojure -M:test

# Run a single namespace
clojure -M:test -n com.blockether.spel.core-test

# Run multiple namespaces
clojure -M:test -n com.blockether.spel.core-test -n com.blockether.spel.page-test

# Run a single test var (MUST be fully-qualified ns/var)
clojure -M:test -v com.blockether.spel.integration-test/proxy-integration-test

# Run multiple vars
clojure -M:test -v com.blockether.spel.options-test/launch-options-test \
                -v com.blockether.spel.options-test/context-options-test

# Run with metadata filter (include/exclude)
clojure -M:test -i :smoke          # only tests tagged ^:smoke
clojure -M:test -e :slow           # exclude tests tagged ^:slow

# Run with Allure reporter
clojure -M:test --output nested --output com.blockether.spel.allure-reporter/allure

# Watch mode (re-runs on file changes)
clojure -M:test --watch

# Run tests from a specific directory
clojure -M:test -d test/com/blockether/spel
```

**IMPORTANT**: The `-v`/`--var` flag requires **fully-qualified symbols** (`namespace/var-name`), not bare var names. Using a bare name will throw `IllegalArgumentException: no conversion to symbol`.

### Test Fixtures

The project provides shared `around` hooks in `com.blockether.spel.test-fixtures`:

| Fixture | Binds | Scope |
|---------|-------|-------|
| `with-playwright` | `*pw*` | Shared Playwright instance |
| `with-browser` | `*browser*` | Shared headless Chromium browser |
| `with-traced-page` | `*page*` | **Default.** Fresh page per `it` block with tracing/HAR always enabled (auto-cleanup) |
| `with-page` | `*page*` | Fresh page per `it` block (auto-cleanup, tracing only when Allure is active) |
| `with-test-server` | `*test-server-url*` | Local HTTP test server |

**Always use `with-traced-page` as the default** — it enables Playwright tracing and HAR capture on every test run, so traces are always available for debugging. Use `with-page` only if you explicitly want tracing disabled outside Allure.

Use `{:context [with-playwright with-browser with-traced-page]}` on `describe` blocks. NEVER nest `with-playwright`/`with-browser`/`with-traced-page` manually inside `it` blocks.

### Test Example

```clojure
(ns my-app.test
  (:require
   [com.blockether.spel.assertions :as assert]
   [com.blockether.spel.locator :as locator]
   [com.blockether.spel.page :as page]
   [com.blockether.spel.test-fixtures :refer [*page* with-playwright with-browser with-traced-page]]
   [com.blockether.spel.allure :refer [defdescribe describe expect it]])
  (:import
   [com.microsoft.playwright.options AriaRole]))

(defdescribe my-test
  (describe "example.com"
    {:context [with-playwright with-browser with-traced-page]}

    (it "navigates and asserts"
      (page/navigate *page* "https://example.com")
      (expect (= "Example Domain" (page/title *page*)))
      (expect (nil? (assert/has-text (assert/assert-that (page/locator *page* "h1")) "Example Domain"))))))
```

---

## Native Image CLI

The library includes a GraalVM native-image compiled binary for instant-start browser automation via CLI.

### Build & Run

```bash
# Build native binary
clojure -T:build uberjar
clojure -T:build native-image

# Install Playwright browsers
./target/spel install
```

{{cli-commands}}

{{sci-api}}

### Snapshot with Refs

The snapshot system walks the DOM and assigns numbered refs (`e1`, `e2`, etc.) to interactive and meaningful elements:

```clojure
(spel/goto "https://example.com")

;; Get accessibility snapshot with refs
(def snap (spel/snapshot))
(:tree snap)
;; => "- heading \"Example Domain\" [@e1] [level=1]\n- link \"More information...\" [@e2]"
(:refs snap)
;; => {"e1" {:role "heading" :name "Example Domain" :tag "h1" :bbox {:x 0 :y 0 :width 500 :height 40}}
;;     "e2" {:role "link" :name "More information..." :tag "a" :bbox {:x 10 :y 100 :width 200 :height 20}}}

;; Click by ref
(spel/click-ref "e2")

;; Fill by ref
(spel/fill-ref "e3" "hello@example.com")

;; Hover by ref
(spel/hover-ref "e1")
```

### Page Annotation

Inject visual overlays (bounding boxes, ref badges, dimension labels) onto the page for **visible elements only**:

```clojure
;; Via CLI:
;;   spel annotate              — inject overlays for visible elements
;;   spel unannotate            — remove overlays
;;   spel screenshot out.png    — capture (with or without overlays)

;; Via Clojure API:
(def snap (spel/snapshot))
(annotate/inject-overlays! *page* (:refs snap))   ;; overlays now visible on page
;; ... inspect in headed mode, take screenshots, etc.
(annotate/remove-overlays! *page*)                 ;; clean up

;; One-shot convenience (inject → screenshot → cleanup):
(spel/save-annotated-screenshot! (:refs snap) "annotated.png")
```

### Daemon Architecture

- Background process keeps browser alive between CLI invocations
- Listens on Unix domain socket (`/tmp/spel-{session}.sock`)
- PID file at `/tmp/spel-{session}.pid`
- JSON protocol over socket (newline-delimited)
- Auto-starts on first CLI command if not running
- `close` command shuts down browser + daemon + cleans up files

---

## GitHub Actions CI/CD

Reference workflows for testing, reporting, native image builds, and deployment.

### CI — Tests + Lint + Native Image (`ci.yml`)

Multi-platform CI (Linux, macOS, Windows) that runs tests, lints, builds native images, and uploads binaries as artifacts.

```yaml
name: CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: read

jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            artifact: spel-dev-linux-amd64
          - os: macos-latest
            artifact: spel-dev-macos-arm64
          - os: windows-latest
            artifact: spel-dev-windows-amd64

    runs-on: ${{ matrix.os }}
    name: CI (${{ matrix.os }})
    defaults:
      run:
        shell: bash
    env:
      # Normalize Playwright browser path across all OSes (macOS default differs)
      PLAYWRIGHT_BROWSERS_PATH: ~/.cache/ms-playwright

    steps:
      - uses: actions/checkout@v4

      - name: Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '25'
          distribution: 'graalvm'

      - uses: DeLaGuardo/setup-clojure@13.5
        with:
          cli: latest

      - uses: clojure-lsp/setup-clojure-lsp@v1
        with:
          clojure-lsp-version: 2025.11.28-12.47.43

      - name: Cache Clojure deps
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.clojure/.cpcache
          key: ${{ runner.os }}-ci-${{ hashFiles('deps.edn') }}
          restore-keys: |
            ${{ runner.os }}-ci-

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('deps.edn') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install Playwright browsers
        run: clojure -M -e "(com.microsoft.playwright.CLI/main (into-array String [\"install\" \"--with-deps\"]))"

      - name: Lint (clojure-lsp)
        if: runner.os == 'Linux'
        run: clojure-lsp diagnostics --raw

      - name: Run tests
        run: clojure -M:test

      - name: Build native image
        run: clojure -T:build native-image

      - name: CLI smoke tests
        run: |
          chmod +x target/spel
          target/spel --help
          target/spel version

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: target/spel
```

**Key details:**
- `PLAYWRIGHT_BROWSERS_PATH` must be normalized — macOS uses a different default path than Linux
- Browser install uses the Java driver CLI (`CLI/main`) so versions match the library exactly
- GraalVM 25 + `graalvm` distribution for native-image
- Lint runs only on Linux (one platform is sufficient)

### Allure Report to GitHub Pages (`allure.yml`)

Runs tests with Allure reporter, generates HTML report with embedded Playwright traces, assembles a multi-build landing page, and deploys to GitHub Pages.

```yaml
name: Allure Report

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: false

env:
  PAGES_BASE_URL: https://<org>.github.io/<repo>
  MAX_REPORTS: 10

jobs:
  report:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: DeLaGuardo/setup-clojure@13.5
        with:
          cli: latest

      - name: Cache Clojure deps
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.clojure/.cpcache
          key: allure-${{ hashFiles('deps.edn') }}

      - name: Install Playwright browsers
        run: clojure -M -e "(com.microsoft.playwright.CLI/main (into-array String [\"install\" \"--with-deps\"]))"

      # Allure 3 uses .allure-history.jsonl for run history.
      # Cache it between builds so trend graphs and history work.
      - name: Restore Allure history
        uses: actions/cache/restore@v4
        with:
          path: .allure-history.jsonl
          key: allure-history-jsonl-${{ github.run_number }}
          restore-keys: allure-history-jsonl-

      # Restore previous per-build reports so the landing page accumulates.
      - name: Restore previous reports
        if: github.ref == 'refs/heads/main'
        uses: actions/cache/restore@v4
        with:
          path: gh-pages-site
          key: allure-site-${{ github.run_number }}
          restore-keys: allure-site-

      - name: Run tests with Allure reporter
        id: tests
        env:
          LAZYTEST_ALLURE_LOGO: logo.svg
          FULL_MSG: ${{ github.event.head_commit.message }}
        run: |
          FIRST_LINE=$(echo "$FULL_MSG" | head -n1 | cut -c1-100)
          export LAZYTEST_ALLURE_REPORT_NAME="#${{ github.run_number }} · $(echo '${{ github.sha }}' | cut -c1-8) · ${FIRST_LINE}"
          clojure -M:test --output nested --output com.blockether.spel.allure-reporter/allure
        continue-on-error: true

      # Inject the GitHub Pages URL and commit metadata into the latest
      # history entry so the landing page can link back to each report.
      - name: Inject report URL and commit info into history
        if: github.ref == 'refs/heads/main'
        env:
          REPORT_URL: ${{ env.PAGES_BASE_URL }}/${{ github.run_number }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          RUN_NUMBER: ${{ github.run_number }}
        run: |
          if [ -f .allure-history.jsonl ]; then
            python3 -c "
          import json, os
          report_url = os.environ['REPORT_URL']
          sha = os.environ.get('COMMIT_SHA', '')[:8]
          msg = os.environ.get('COMMIT_MSG', '').split('\n')[0][:100]
          run = os.environ.get('RUN_NUMBER', '')
          name = f'#{run} · {sha} · {msg}'
          lines = open('.allure-history.jsonl').read().strip().split('\n')
          result = []
          for i, line in enumerate(lines):
              if not line.strip():
                  continue
              entry = json.loads(line)
              if i == len(lines) - 1:
                  entry['url'] = report_url
                  entry['name'] = name
                  for tid in entry.get('testResults', {}):
                      entry['testResults'][tid]['url'] = report_url
              result.append(json.dumps(entry, separators=(',', ':')))
          with open('.allure-history.jsonl', 'w') as f:
              f.write('\n'.join(result) + '\n')
          "
          fi

      # Assemble a multi-build site:
      #   gh-pages-site/
      #     index.html          — landing page with build list
      #     builds.json         — metadata for JS rendering
      #     latest/index.html   — redirect to newest report
      #     <run_number>/       — each Allure HTML report
      - name: Assemble site with per-build reports
        if: github.ref == 'refs/heads/main'
        env:
          RUN_NUMBER: ${{ github.run_number }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          COMMIT_TS: ${{ github.event.head_commit.timestamp }}
          TEST_PASSED: ${{ steps.tests.outcome == 'success' }}
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          RUN="${{ github.run_number }}"
          mkdir -p gh-pages-site
          cp -r allure-report "gh-pages-site/${RUN}"

          cd gh-pages-site

          # Prune oldest reports beyond MAX_REPORTS
          DIRS=$(ls -1d [0-9]* 2>/dev/null | sort -n)
          COUNT=$(echo "$DIRS" | grep -c .)
          if [ "$COUNT" -gt "$MAX_REPORTS" ]; then
            REMOVE=$((COUNT - MAX_REPORTS))
            echo "$DIRS" | head -n "$REMOVE" | while read -r dir; do
              rm -rf "$dir"
            done
          fi

          # Generate builds.json for the landing page
          BUILDS_META="builds-meta.json"
          [ -f "$BUILDS_META" ] || echo '{}' > "$BUILDS_META"

          python3 -c "
          import json, os, time
          meta_file = '$BUILDS_META'
          meta = json.load(open(meta_file))
          run = os.environ['RUN_NUMBER']
          sha = os.environ.get('COMMIT_SHA', '')
          msg = os.environ.get('COMMIT_MSG', '').split('\n')[0]
          ts_str = os.environ.get('COMMIT_TS', '')
          ts = int(time.time() * 1000)
          if ts_str:
              from datetime import datetime
              try:
                  dt = datetime.fromisoformat(ts_str.replace('Z', '+00:00'))
                  ts = int(dt.timestamp() * 1000)
              except Exception:
                  pass
          passed = os.environ.get('TEST_PASSED', 'false') == 'true'
          repo_url = os.environ.get('REPO_URL', '')
          run_url = os.environ.get('RUN_URL', '')
          meta[run] = {'sha': sha, 'message': msg, 'timestamp': ts, 'passed': passed, 'repo_url': repo_url, 'run_url': run_url}
          dirs = sorted([d for d in os.listdir('.') if d.isdigit()], key=int, reverse=True)
          pruned = {k: v for k, v in meta.items() if k in dirs}
          json.dump(pruned, open(meta_file, 'w'), separators=(',', ':'))
          builds = []
          for d in dirs:
              entry = pruned.get(d, {})
              builds.append({'run': d, 'sha': entry.get('sha', ''), 'message': entry.get('message', ''), 'timestamp': entry.get('timestamp', 0), 'passed': entry.get('passed', True), 'repo_url': entry.get('repo_url', ''), 'run_url': entry.get('run_url', '')})
          json.dump(builds, open('builds.json', 'w'), separators=(',', ':'))
          "

          # Landing page + /latest redirect
          cp ../resources/allure-index.html index.html
          mkdir -p latest
          cat > latest/index.html <<EOF
          <!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="refresh" content="0; url=../${RUN}/"></head><body></body></html>
          EOF
          cd ..

      - name: Cache Allure history
        if: github.ref == 'refs/heads/main'
        uses: actions/cache/save@v4
        with:
          path: .allure-history.jsonl
          key: allure-history-jsonl-${{ github.run_number }}

      - name: Cache site archive
        if: github.ref == 'refs/heads/main'
        uses: actions/cache/save@v4
        with:
          path: gh-pages-site
          key: allure-site-${{ github.run_number }}

      - name: Upload Pages artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-pages-artifact@v3
        with:
          path: gh-pages-site

      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        id: deployment
        uses: actions/deploy-pages@v4
```

**Key details:**
- **History**: `.allure-history.jsonl` is cached between builds — Allure 3 uses this for trend graphs and run history
- **Multi-build site**: Each run gets its own subdirectory (`gh-pages-site/<run_number>/`), pruned to `MAX_REPORTS`
- **Landing page**: `allure-index.html` renders `builds.json` — shows commit SHA (clickable to repo), date, pass/fail status, and links to each report
- **`/latest` redirect**: `gh-pages-site/latest/index.html` meta-refreshes to the newest report number
- **`continue-on-error: true`**: Test failures don't block report generation — the report shows what failed
- **Report naming**: `#<run> · <sha8> · <commit msg first line>` for clear identification in Allure history

### Native Image Build + Release (`native-image.yml`)

Cross-platform native image build with automatic GitHub Release on tags.

```yaml
name: Native Image Build

on:
  push:
    branches: [main]
    tags: ['v*']

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            arch: amd64
            artifact: spel-linux-amd64
          - os: ubuntu-24.04-arm
            arch: arm64
            artifact: spel-linux-arm64
          - os: macos-latest
            arch: arm64
            artifact: spel-macos-arm64
          - os: windows-latest
            arch: amd64
            artifact: spel-windows-amd64

    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: bash
    env:
      PLAYWRIGHT_BROWSERS_PATH: ~/.cache/ms-playwright

    steps:
      - uses: actions/checkout@v4

      - name: Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '25'
          distribution: 'graalvm'

      - uses: DeLaGuardo/setup-clojure@13.5
        with:
          cli: latest

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('deps.edn') }}

      - name: Install Playwright browsers
        run: clojure -M -e "(com.microsoft.playwright.CLI/main (into-array String [\"install\" \"--with-deps\"]))"

      - name: Build uberjar + native image
        run: |
          clojure -T:build uberjar
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            "$GRAALVM_HOME/bin/native-image.cmd" -jar target/spel-standalone.jar -o target/spel
          else
            native-image -jar target/spel-standalone.jar -o target/spel
          fi

      - name: CLI smoke tests
        run: |
          chmod +x target/spel || true
          target/spel --help
          target/spel version

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: target/spel*

  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            artifacts/spel-linux-amd64/spel-linux-amd64
            artifacts/spel-linux-arm64/spel-linux-arm64
            artifacts/spel-macos-arm64/spel-macos-arm64
            artifacts/spel-windows-amd64/spel-windows-amd64.exe
```

**Key details:**
- Linux arm64 uses `ubuntu-24.04-arm` runner (GitHub's ARM runner)
- Windows native-image uses `$GRAALVM_HOME/bin/native-image.cmd` (not `native-image` directly)
- Release job downloads all platform artifacts and creates a GitHub Release with binaries attached
- Triggered on `v*` tags (e.g. `git tag v0.1.0 && git push --tags`)

### Deploy to Clojars (`deploy.yml`)

Publishes JAR to Clojars and creates a GitHub Release with auto-generated changelog on version tags.

```yaml
name: Deploy to Clojars

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: DeLaGuardo/setup-clojure@13.5
        with:
          cli: latest

      - name: Build & Deploy to Clojars
        env:
          VERSION: ${{ github.ref_name }}
          CLOJARS_USERNAME: <your-deployer>
          CLOJARS_PASSWORD: ${{ secrets.CLOJARS_DEPLOY_TOKEN }}
        run: clojure -T:build deploy

      - name: Update README + CHANGELOG
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          sed -i "s/{:mvn\/version \"[^\"]*\"}/{:mvn\/version \"$VERSION\"}/g" README.md
          # ... update CHANGELOG.md with git log between tags ...
          git config user.name "deployer"
          git config user.email "deploy@example.com"
          git add README.md CHANGELOG.md
          git commit -m "release: update for ${{ github.ref_name }}" || true
          git push origin HEAD:main
```

**Key details:**
- `fetch-depth: 0` — full git history needed for changelog generation between tags
- `CLOJARS_DEPLOY_TOKEN` stored as GitHub secret
- Auto-updates `README.md` version string and `CHANGELOG.md` after deploy
- Pushes version bump commit back to `main`

### Prerequisites for GitHub Pages

Before the Allure workflow can deploy:

1. **Enable GitHub Pages** in repo settings → Pages → Source: **GitHub Actions**
2. **Create environment** named `github-pages` (Settings → Environments)
3. **Set `PAGES_BASE_URL`** in the workflow env to `https://<org>.github.io/<repo>`
4. **Landing page**: Place `allure-index.html` in `resources/` — it renders `builds.json` client-side with build list, commit links, pass/fail badges, and date grouping

---

## Rules

| Rule | Detail |
|------|--------|
| **No per-file reflection warnings** | Handled globally by build tooling |
| **No `clj-kondo` CLI** | All linting via `clojure-lsp diagnostics --raw` |
| **Anomalies not exceptions** | Use `com.blockether.anomaly` pattern |
| **Error type keywords** | `:playwright.error/timeout`, `:playwright.error/target-closed`, etc. |
| **Exact string assertions** | Never use substring matching unless `contains-text` |
| **`new-page-from-context`** | For creating pages from BrowserContext (not `new-page`) |
| **AriaRole import** | Always `(:import [com.microsoft.playwright.options AriaRole])` |
| **`with-*` macros** | Always use for resource cleanup (never manual try/finally) |

---

## CLI Entry Points

The `spel` binary is the primary CLI interface:

| Command | Purpose |
|---------|---------|
| `spel <command>` | Browser automation CLI (100+ commands) |
| `spel codegen` | Record and transform browser sessions to Clojure |
| `spel init-agents` | Scaffold E2E testing agents (`--loop=opencode\|claude\|vscode`) |
