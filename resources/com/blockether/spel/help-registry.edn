[{:ns "spel", :name "$", :arglists "[sel-or-loc]", :doc "Resolves a ref ID to a Playwright Locator.", :lib-source "com.blockether.spel.snapshot/resolve-ref", :wrapper-source "(defn sci-$            [sel-or-loc]\n  (if (instance? Locator sel-or-loc)\n    sel-or-loc\n    (let [s (str sel-or-loc)]\n      (if (ref? s)\n        (snapshot/resolve-ref (require-page!) (str/replace s #\"^@\" \"\"))\n        (page/locator (require-page!) s)))))"} {:ns "spel", :name "$$", :arglists "[sel]", :doc "Returns all elements matching the locator as individual locators.", :lib-source "com.blockether.spel.locator/all", :wrapper-source "(defn sci-$$           [sel]  (locator/all (sci-$ sel)))"} {:ns "spel", :name "$alt-text", :arglists "[text]", :doc "Locates elements by alt text.", :lib-source "com.blockether.spel.page/get-by-alt-text", :wrapper-source "(defn sci-$alt-text    [text] (page/get-by-alt-text (require-page!) text))"} {:ns "spel", :name "$label", :arglists "[text]", :doc "Locates elements by their label text.", :lib-source "com.blockether.spel.page/get-by-label", :wrapper-source "(defn sci-$label       [text] (page/get-by-label (require-page!) text))"} {:ns "spel", :name "$placeholder", :arglists "[text]", :doc "Locates elements by placeholder text.", :lib-source "com.blockether.spel.page/get-by-placeholder", :wrapper-source "(defn sci-$placeholder [text] (page/get-by-placeholder (require-page!) text))"} {:ns "spel", :name "$role", :arglists "[role] | [role opts]", :doc "Locates elements by their ARIA role.", :lib-source "com.blockether.spel.page/get-by-role", :wrapper-source "(defn sci-$role\n  ([role]      (page/get-by-role (require-page!) role))\n  ([role opts] (page/get-by-role (require-page!) role opts)))"} {:ns "spel", :name "$test-id", :arglists "[id]", :doc "Locates elements by test ID attribute.", :lib-source "com.blockether.spel.page/get-by-test-id", :wrapper-source "(defn sci-$test-id     [id]   (page/get-by-test-id (require-page!) id))"} {:ns "spel", :name "$text", :arglists "[text]", :doc "Locates elements by their text content.", :lib-source "com.blockether.spel.page/get-by-text", :wrapper-source "(defn sci-$text        [text] (page/get-by-text (require-page!) text))"} {:ns "spel", :name "$title-attr", :arglists "[text]", :doc "Locates elements by title attribute.", :lib-source "com.blockether.spel.page/get-by-title", :wrapper-source "(defn sci-$title-attr  [text] (page/get-by-title (require-page!) text))\n\n;; =============================================================================\n;; Locator Actions\n;; ============================================================================="} {:ns "spel", :name "add-script-tag", :arglists "[opts]", :doc "Adds a script tag to the page.", :lib-source "com.blockether.spel.page/add-script-tag", :wrapper-source "(defn sci-add-script-tag [opts]\n  (throw-if-anomaly (page/add-script-tag (require-page!) opts)))"} {:ns "spel", :name "add-style-tag", :arglists "[opts]", :doc "Adds a style tag to the page.", :lib-source "com.blockether.spel.page/add-style-tag", :wrapper-source "(defn sci-add-style-tag [opts]\n  (throw-if-anomaly (page/add-style-tag (require-page!) opts)))"} {:ns "spel", :name "all-inner-texts", :arglists "[sel]", :doc "Returns all inner texts for matching elements.", :lib-source "com.blockether.spel.locator/all-inner-texts", :wrapper-source "(defn sci-all-inner-texts   [sel] (locator/all-inner-texts (sci-$ sel)))\n\n;; =============================================================================\n;; Locator Filtering\n;; ============================================================================="} {:ns "spel", :name "all-text-contents", :arglists "[sel]", :doc "Returns all text contents for matching elements.", :lib-source "com.blockether.spel.locator/all-text-contents", :wrapper-source "(defn sci-all-text-contents [sel] (locator/all-text-contents (sci-$ sel)))"} {:ns "spel", :name "annotate", :arglists "[refs] | [refs opts]", :doc "Injects annotation overlays into the current page for visible elements.", :lib-source "com.blockether.spel.annotate/inject-overlays!", :wrapper-source "(defn sci-annotate\n  \"Injects annotation overlays into the current page for visible elements.\n   Takes refs from snapshot and optional display opts.\"\n  ([refs] (annotate/inject-overlays! (require-page!) refs))\n  ([refs opts] (annotate/inject-overlays! (require-page!) refs opts)))"} {:ns "spel", :name "annotated-screenshot", :arglists "[refs] | [refs opts]", :doc "Takes a screenshot with annotation overlays (convenience function).", :lib-source "com.blockether.spel.annotate/annotated-screenshot", :wrapper-source "(defn sci-annotated-screenshot\n  ([refs] (throw-if-anomaly (annotate/annotated-screenshot (require-page!) refs)))\n  ([refs opts] (throw-if-anomaly (annotate/annotated-screenshot (require-page!) refs opts))))"} {:ns "spel", :name "assert-accessible-description", :arglists "[sel desc]", :doc "Asserts the locator has the specified accessible description.", :lib-source "com.blockether.spel.assertions/has-accessible-description", :wrapper-source "(defn sci-assert-accessible-description [sel desc]\n  (throw-if-anomaly (assert/has-accessible-description (->locator-assertions sel) desc)))"} {:ns "spel", :name "assert-accessible-error-message", :arglists "[sel msg]", :doc "Asserts the locator has the specified accessible error message.", :lib-source "com.blockether.spel.assertions/has-accessible-error-message", :wrapper-source "(defn sci-assert-accessible-error-message [sel msg]\n  (throw-if-anomaly (assert/has-accessible-error-message (->locator-assertions sel) msg)))"} {:ns "spel", :name "assert-accessible-name", :arglists "[sel name-val]", :doc "Asserts the locator has the specified accessible name.", :lib-source "com.blockether.spel.assertions/has-accessible-name", :wrapper-source "(defn sci-assert-accessible-name [sel name-val]\n  (throw-if-anomaly (assert/has-accessible-name (->locator-assertions sel) name-val)))"} {:ns "spel", :name "assert-attached", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is attached to the DOM.", :lib-source "com.blockether.spel.assertions/is-attached", :wrapper-source "(defn sci-assert-attached\n  ([sel]      (throw-if-anomaly (assert/is-attached (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-attached (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-attr", :arglists "[sel attr-name value] | [sel attr-name value opts]", :doc "Asserts the locator has the specified attribute with value.", :lib-source "com.blockether.spel.assertions/has-attribute", :wrapper-source "(defn sci-assert-attr\n  ([sel attr-name value]      (throw-if-anomaly (assert/has-attribute (->locator-assertions sel) attr-name value)))\n  ([sel attr-name value opts] (throw-if-anomaly (assert/has-attribute (->locator-assertions sel) attr-name value opts))))"} {:ns "spel", :name "assert-checked", :arglists "[sel] | [sel opts]", :doc "Asserts the locator (checkbox/radio) is checked.", :lib-source "com.blockether.spel.assertions/is-checked", :wrapper-source "(defn sci-assert-checked\n  ([sel]      (throw-if-anomaly (assert/is-checked (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-checked (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-class", :arglists "[sel class-val] | [sel class-val opts]", :doc "Asserts the locator has the specified CSS class.", :lib-source "com.blockether.spel.assertions/has-class", :wrapper-source "(defn sci-assert-class\n  ([sel class-val]      (throw-if-anomaly (assert/has-class (->locator-assertions sel) class-val)))\n  ([sel class-val opts] (throw-if-anomaly (assert/has-class (->locator-assertions sel) class-val opts))))"} {:ns "spel", :name "assert-contains-class", :arglists "[sel class-val] | [sel class-val opts]", :doc "Asserts the locator's class attribute contains the specified class.", :lib-source "com.blockether.spel.assertions/contains-class", :wrapper-source "(defn sci-assert-contains-class\n  ([sel class-val]      (throw-if-anomaly (assert/contains-class (->locator-assertions sel) class-val)))\n  ([sel class-val opts] (throw-if-anomaly (assert/contains-class (->locator-assertions sel) class-val opts))))"} {:ns "spel", :name "assert-contains-text", :arglists "[sel expected] | [sel expected opts]", :doc "Asserts the locator contains the specified text.", :lib-source "com.blockether.spel.assertions/contains-text", :wrapper-source "(defn sci-assert-contains-text\n  ([sel expected]      (throw-if-anomaly (assert/contains-text (->locator-assertions sel) expected)))\n  ([sel expected opts] (throw-if-anomaly (assert/contains-text (->locator-assertions sel) expected opts))))\n\n;; Locator attribute/class/css assertions"} {:ns "spel", :name "assert-count", :arglists "[sel n] | [sel n opts]", :doc "Asserts the locator resolves to the expected number of elements.", :lib-source "com.blockether.spel.assertions/has-count", :wrapper-source "(defn sci-assert-count\n  ([sel n]      (throw-if-anomaly (assert/has-count (->locator-assertions sel) n)))\n  ([sel n opts] (throw-if-anomaly (assert/has-count (->locator-assertions sel) n opts))))\n\n;; Locator ARIA assertions"} {:ns "spel", :name "assert-css", :arglists "[sel css-name value] | [sel css-name value opts]", :doc "Asserts the locator has the specified CSS property with value.", :lib-source "com.blockether.spel.assertions/has-css", :wrapper-source "(defn sci-assert-css\n  ([sel css-name value]      (throw-if-anomaly (assert/has-css (->locator-assertions sel) css-name value)))\n  ([sel css-name value opts] (throw-if-anomaly (assert/has-css (->locator-assertions sel) css-name value opts))))"} {:ns "spel", :name "assert-disabled", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is disabled.", :lib-source "com.blockether.spel.assertions/is-disabled", :wrapper-source "(defn sci-assert-disabled\n  ([sel]      (throw-if-anomaly (assert/is-disabled (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-disabled (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-editable", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is editable.", :lib-source "com.blockether.spel.assertions/is-editable", :wrapper-source "(defn sci-assert-editable\n  ([sel]      (throw-if-anomaly (assert/is-editable (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-editable (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-empty", :arglists "[sel]", :doc "Asserts the locator (input) is empty.", :lib-source "com.blockether.spel.assertions/is-empty", :wrapper-source "(defn sci-assert-empty [sel]\n  (throw-if-anomaly (assert/is-empty (->locator-assertions sel))))"} {:ns "spel", :name "assert-enabled", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is enabled.", :lib-source "com.blockether.spel.assertions/is-enabled", :wrapper-source "(defn sci-assert-enabled\n  ([sel]      (throw-if-anomaly (assert/is-enabled (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-enabled (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-focused", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is focused.", :lib-source "com.blockether.spel.assertions/is-focused", :wrapper-source "(defn sci-assert-focused\n  ([sel]      (throw-if-anomaly (assert/is-focused (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-focused (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-hidden", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is hidden.", :lib-source "com.blockether.spel.assertions/is-hidden", :wrapper-source "(defn sci-assert-hidden\n  ([sel]      (throw-if-anomaly (assert/is-hidden (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-hidden (->locator-assertions sel) opts))))"} {:ns "spel", :name "assert-id", :arglists "[sel id] | [sel id opts]", :doc "Asserts the locator has the specified ID.", :lib-source "com.blockether.spel.assertions/has-id", :wrapper-source "(defn sci-assert-id\n  ([sel id]      (throw-if-anomaly (assert/has-id (->locator-assertions sel) id)))\n  ([sel id opts] (throw-if-anomaly (assert/has-id (->locator-assertions sel) id opts))))"} {:ns "spel", :name "assert-in-viewport", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is in the viewport.", :lib-source "com.blockether.spel.assertions/is-in-viewport", :wrapper-source "(defn sci-assert-in-viewport\n  ([sel]      (throw-if-anomaly (assert/is-in-viewport (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-in-viewport (->locator-assertions sel) opts))))\n\n;; Page assertions"} {:ns "spel", :name "assert-js-property", :arglists "[sel prop-name value]", :doc "Asserts the locator has the specified JavaScript property.", :lib-source "com.blockether.spel.assertions/has-js-property", :wrapper-source "(defn sci-assert-js-property [sel prop-name value]\n  (throw-if-anomaly (assert/has-js-property (->locator-assertions sel) prop-name value)))\n\n;; Locator value assertions"} {:ns "spel", :name "assert-matches-aria-snapshot", :arglists "[sel snapshot-str]", :doc "Asserts the locator matches the ARIA snapshot.", :lib-source "com.blockether.spel.assertions/matches-aria-snapshot", :wrapper-source "(defn sci-assert-matches-aria-snapshot [sel snapshot-str]\n  (throw-if-anomaly (assert/matches-aria-snapshot (->locator-assertions sel) snapshot-str)))\n\n;; Locator state assertions"} {:ns "spel", :name "assert-not", :arglists "[sel]", :doc "Returns negated LocatorAssertions (expect the opposite).", :lib-source "com.blockether.spel.assertions/loc-not", :wrapper-source "(defn sci-assert-not  [sel] (assert/loc-not (->locator-assertions sel)))"} {:ns "spel", :name "assert-page-not", :arglists "[]", :doc "Returns negated PageAssertions (expect the opposite).", :lib-source "com.blockether.spel.assertions/page-not", :wrapper-source "(defn sci-assert-page-not [] (assert/page-not (assert/assert-that (require-page!))))"} {:ns "spel", :name "assert-role", :arglists "[sel role]", :doc "Asserts the locator has the specified ARIA role.", :lib-source "com.blockether.spel.assertions/has-role", :wrapper-source "(defn sci-assert-role [sel role]\n  (throw-if-anomaly (assert/has-role (->locator-assertions sel) role)))"} {:ns "spel", :name "assert-text", :arglists "[sel expected] | [sel expected opts]", :doc "Asserts the locator has the specified text.", :lib-source "com.blockether.spel.assertions/has-text", :wrapper-source "(defn sci-assert-text\n  ([sel expected]      (throw-if-anomaly (assert/has-text (->locator-assertions sel) expected)))\n  ([sel expected opts] (throw-if-anomaly (assert/has-text (->locator-assertions sel) expected opts))))"} {:ns "spel", :name "assert-that", :arglists "[target]", :doc "Creates an assertion object for the given Playwright instance.", :lib-source "com.blockether.spel.assertions/assert-that", :wrapper-source "(defn sci-assert-that [target] (assert/assert-that target))"} {:ns "spel", :name "assert-title", :arglists "[expected] | [expected opts]", :doc "Asserts the page has the specified title.", :lib-source "com.blockether.spel.assertions/has-title", :wrapper-source "(defn sci-assert-title\n  ([expected]      (throw-if-anomaly (assert/has-title (assert/assert-that (require-page!)) expected)))\n  ([expected opts] (throw-if-anomaly (assert/has-title (assert/assert-that (require-page!)) expected opts))))"} {:ns "spel", :name "assert-url", :arglists "[expected] | [expected opts]", :doc "Asserts the page has the specified URL.", :lib-source "com.blockether.spel.assertions/has-url", :wrapper-source "(defn sci-assert-url\n  ([expected]      (throw-if-anomaly (assert/has-url (assert/assert-that (require-page!)) expected)))\n  ([expected opts] (throw-if-anomaly (assert/has-url (assert/assert-that (require-page!)) expected opts))))\n\n;; =============================================================================\n;; Page Functions\n;; ============================================================================="} {:ns "spel", :name "assert-value", :arglists "[sel value] | [sel value opts]", :doc "Asserts the locator (input) has the specified value.", :lib-source "com.blockether.spel.assertions/has-value", :wrapper-source "(defn sci-assert-value\n  ([sel value]      (throw-if-anomaly (assert/has-value (->locator-assertions sel) value)))\n  ([sel value opts] (throw-if-anomaly (assert/has-value (->locator-assertions sel) value opts))))"} {:ns "spel", :name "assert-values", :arglists "[sel values] | [sel values opts]", :doc "Asserts the locator (multi-select) has the specified values.", :lib-source "com.blockether.spel.assertions/has-values", :wrapper-source "(defn sci-assert-values\n  ([sel values]      (throw-if-anomaly (assert/has-values (->locator-assertions sel) values)))\n  ([sel values opts] (throw-if-anomaly (assert/has-values (->locator-assertions sel) values opts))))\n\n;; Locator count assertion"} {:ns "spel", :name "assert-visible", :arglists "[sel] | [sel opts]", :doc "Asserts the locator is visible.", :lib-source "com.blockether.spel.assertions/is-visible", :wrapper-source "(defn sci-assert-visible\n  ([sel]      (throw-if-anomaly (assert/is-visible (->locator-assertions sel))))\n  ([sel opts] (throw-if-anomaly (assert/is-visible (->locator-assertions sel) opts))))"} {:ns "spel", :name "attr", :arglists "[sel name]", :doc "Returns the value of an attribute.", :lib-source "com.blockether.spel.locator/get-attribute", :wrapper-source "(defn sci-attr       [sel name] (throw-if-anomaly (locator/get-attribute (sci-$ sel) name)))"} {:ns "spel", :name "audit-screenshot", :arglists "[caption] | [caption opts]", :doc "Takes a screenshot with a caption bar at the bottom.", :lib-source "com.blockether.spel.annotate/audit-screenshot", :wrapper-source "(defn sci-audit-screenshot\n  \"Takes a screenshot with a caption bar at the bottom.\"\n  ([caption] (throw-if-anomaly (annotate/audit-screenshot (require-page!) caption)))\n  ([caption opts] (throw-if-anomaly (annotate/audit-screenshot (require-page!) caption opts))))"} {:ns "spel", :name "back", :arglists "[]", :doc "Navigates back in history.", :lib-source "com.blockether.spel.page/go-back", :wrapper-source "(defn sci-back      [] (throw-if-anomaly (page/go-back (require-page!))))"} {:ns "spel", :name "bbox", :arglists "[sel]", :doc "Returns the bounding box of the element.", :lib-source "com.blockether.spel.locator/bounding-box", :wrapper-source "(defn sci-bbox       [sel] (locator/bounding-box (sci-$ sel)))"} {:ns "spel", :name "blur", :arglists "[sel]", :doc "Blurs (removes focus from) the element.", :lib-source "com.blockether.spel.locator/blur", :wrapper-source "(defn sci-blur      [sel] (throw-if-anomaly (locator/blur (sci-$ sel))))"} {:ns "spel", :name "bring-to-front", :arglists "[]", :doc "Brings page to front (activates tab).", :lib-source "com.blockether.spel.page/bring-to-front", :wrapper-source "(defn sci-bring-to-front []\n  (page/bring-to-front (require-page!)))"} {:ns "spel", :name "browser", :arglists "[]", :doc "Returns the current Browser instance.", :wrapper-source "(defn sci-browser\n  \"Returns the current Browser instance.\"\n  [] (require-browser!))"} {:ns "spel", :name "browser-connected?", :arglists "[]", :doc "Returns true if the browser is connected.", :lib-source "com.blockether.spel.core/browser-connected?", :wrapper-source "(defn sci-browser-connected? [] (core/browser-connected? (require-browser!)))"} {:ns "spel", :name "browser-version", :arglists "[]", :doc "Returns the browser version string.", :lib-source "com.blockether.spel.core/browser-version", :wrapper-source "(defn sci-browser-version    [] (core/browser-version (require-browser!)))\n\n;; =============================================================================\n;; Tracing\n;; ============================================================================="} {:ns "spel", :name "check", :arglists "[sel] | [sel opts]", :doc "Checks a checkbox or radio button.", :lib-source "com.blockether.spel.locator/check", :wrapper-source "(defn sci-check\n  ([sel]      (throw-if-anomaly (locator/check (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/check (sci-$ sel) opts))))"} {:ns "spel", :name "checked?", :arglists "[sel]", :doc "Returns whether the element is checked.", :lib-source "com.blockether.spel.locator/is-checked?", :wrapper-source "(defn sci-checked?   [sel] (locator/is-checked? (sci-$ sel)))"} {:ns "spel", :name "clear", :arglists "[sel]", :doc "Clears input field content.", :lib-source "com.blockether.spel.locator/clear", :wrapper-source "(defn sci-clear   [sel] (throw-if-anomaly (locator/clear (sci-$ sel))))"} {:ns "spel", :name "clear-refs!", :arglists "[]", :doc "Removes all data-pw-ref attributes from the page.", :lib-source "com.blockether.spel.snapshot/clear-refs!", :wrapper-source "(defn sci-clear-refs! []\n  (snapshot/clear-refs! (require-page!)))"} {:ns "spel", :name "click", :arglists "[sel] | [sel opts]", :doc "Clicks an element.", :lib-source "com.blockether.spel.locator/click", :wrapper-source "(defn sci-click\n  ([sel]      (throw-if-anomaly (locator/click (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/click (sci-$ sel) opts))))"} {:ns "spel", :name "context", :arglists "[]", :doc "Returns the current BrowserContext instance.", :wrapper-source "(defn sci-context\n  \"Returns the current BrowserContext instance.\"\n  [] (require-context!))"} {:ns "spel", :name "context-clear-cookies!", :arglists "[]", :doc "Clears all cookies in the context.", :lib-source "com.blockether.spel.core/context-clear-cookies!", :wrapper-source "(defn sci-context-clear-cookies!   [] (core/context-clear-cookies! (require-context!)))"} {:ns "spel", :name "context-clear-permissions!", :arglists "[]", :doc "Clears all granted permissions.", :lib-source "com.blockether.spel.core/context-clear-permissions!", :wrapper-source "(defn sci-context-clear-permissions! [] (core/context-clear-permissions! (require-context!)))"} {:ns "spel", :name "context-cookies", :arglists "[]", :doc "Returns all cookies in the context.", :lib-source "com.blockether.spel.core/context-cookies", :wrapper-source "(defn sci-context-cookies          [] (core/context-cookies (require-context!)))"} {:ns "spel", :name "context-grant-permissions!", :arglists "[perms]", :doc "Grants permissions to the context.", :lib-source "com.blockether.spel.core/context-grant-permissions!", :wrapper-source "(defn sci-context-grant-permissions! [perms] (core/context-grant-permissions! (require-context!) perms))"} {:ns "spel", :name "context-route-from-har!", :arglists "[har] | [har opts]", :doc "Routes requests in the context from a HAR file. Replays recorded responses", :lib-source "com.blockether.spel.core/context-route-from-har!", :wrapper-source "(defn sci-context-route-from-har!\n  ([har]      (throw-if-anomaly (core/context-route-from-har! (require-context!) har)))\n  ([har opts] (throw-if-anomaly (core/context-route-from-har! (require-context!) har opts))))"} {:ns "spel", :name "context-route-web-socket!", :arglists "[pattern handler]", :doc "Registers a handler for WebSocket connections matching a URL pattern", :lib-source "com.blockether.spel.core/context-route-web-socket!", :wrapper-source "(defn sci-context-route-web-socket! [pattern handler]\n  (core/context-route-web-socket! (require-context!) pattern handler))"} {:ns "spel", :name "context-save-storage-state!", :arglists "[path]", :doc "Saves the storage state (cookies, localStorage) to a file.", :lib-source "com.blockether.spel.core/context-save-storage-state!", :wrapper-source "(defn sci-context-save-storage-state! [path] (core/context-save-storage-state! (require-context!) path))"} {:ns "spel", :name "context-set-extra-http-headers!", :arglists "[headers]", :doc "Sets extra HTTP headers for all requests in the context.", :lib-source "com.blockether.spel.core/context-set-extra-http-headers!", :wrapper-source "(defn sci-context-set-extra-http-headers! [headers] (core/context-set-extra-http-headers! (require-context!) headers))"} {:ns "spel", :name "context-set-offline!", :arglists "[offline]", :doc "Sets the context to offline or online mode.", :lib-source "com.blockether.spel.core/context-set-offline!", :wrapper-source "(defn sci-context-set-offline!     [offline] (core/context-set-offline! (require-context!) offline))"} {:ns "spel", :name "context-storage-state", :arglists "[]", :doc "Returns the storage state (cookies, localStorage) as a JSON string.", :lib-source "com.blockether.spel.core/context-storage-state", :wrapper-source "(defn sci-context-storage-state    [] (core/context-storage-state (require-context!)))"} {:ns "spel", :name "count-of", :arglists "[sel]", :doc "Returns the number of elements matching the locator.", :lib-source "com.blockether.spel.locator/count-elements", :wrapper-source "(defn sci-count-of   [sel] (throw-if-anomaly (locator/count-elements (sci-$ sel))))"} {:ns "spel", :name "dblclick", :arglists "[sel] | [sel opts]", :doc "Double-clicks an element.", :lib-source "com.blockether.spel.locator/dblclick", :wrapper-source "(defn sci-dblclick\n  ([sel]      (throw-if-anomaly (locator/dblclick (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/dblclick (sci-$ sel) opts))))"} {:ns "spel", :name "disabled?", :arglists "[sel]", :doc "Returns whether the element is disabled.", :lib-source "com.blockether.spel.locator/is-disabled?", :wrapper-source "(defn sci-disabled?  [sel] (locator/is-disabled? (sci-$ sel)))"} {:ns "spel", :name "dispatch-event", :arglists "[sel type]", :doc "Dispatches a DOM event on the element.", :lib-source "com.blockether.spel.locator/dispatch-event", :wrapper-source "(defn sci-dispatch-event   [sel type] (throw-if-anomaly (locator/dispatch-event (sci-$ sel) type)))"} {:ns "spel", :name "drag-to", :arglists "[sel target-sel]", :doc "Drags this locator to another locator.", :lib-source "com.blockether.spel.locator/drag-to", :wrapper-source "(defn sci-drag-to          [sel target-sel] (throw-if-anomaly (locator/drag-to (sci-$ sel) (sci-$ target-sel))))"} {:ns "spel", :name "editable?", :arglists "[sel]", :doc "Returns whether the element is editable.", :lib-source "com.blockether.spel.locator/is-editable?", :wrapper-source "(defn sci-editable?  [sel] (locator/is-editable? (sci-$ sel)))"} {:ns "spel", :name "emulate-media!", :arglists "[opts]", :doc "Emulates media type and features.", :lib-source "com.blockether.spel.page/emulate-media!", :wrapper-source "(defn sci-emulate-media! [opts]\n  (throw-if-anomaly (page/emulate-media! (require-page!) opts)))"} {:ns "spel", :name "enabled?", :arglists "[sel]", :doc "Returns whether the element is enabled.", :lib-source "com.blockether.spel.locator/is-enabled?", :wrapper-source "(defn sci-enabled?   [sel] (locator/is-enabled? (sci-$ sel)))"} {:ns "spel", :name "eval-js", :arglists "[expr] | [expr arg]", :doc "Evaluates JavaScript expression in the page context.", :lib-source "com.blockether.spel.page/evaluate", :wrapper-source "(defn sci-eval-js\n  ([expr]     (throw-if-anomaly (page/evaluate (require-page!) expr)))\n  ([expr arg] (throw-if-anomaly (page/evaluate (require-page!) expr arg))))"} {:ns "spel", :name "evaluate-all-locs", :arglists "[sel expr] | [sel expr arg]", :doc "Evaluates JavaScript on all elements matching the locator.", :lib-source "com.blockether.spel.locator/evaluate-all", :wrapper-source "(defn sci-evaluate-all-locs\n  ([sel expr]     (throw-if-anomaly (locator/evaluate-all (sci-$ sel) expr)))\n  ([sel expr arg] (throw-if-anomaly (locator/evaluate-all (sci-$ sel) expr arg))))\n\n;; =============================================================================\n;; JavaScript\n;; ============================================================================="} {:ns "spel", :name "evaluate-handle", :arglists "[expr] | [expr arg]", :doc "Like evaluate, but returns a JSHandle.", :lib-source "com.blockether.spel.page/evaluate-handle", :wrapper-source "(defn sci-evaluate-handle\n  ([expr]     (throw-if-anomaly (page/evaluate-handle (require-page!) expr)))\n  ([expr arg] (throw-if-anomaly (page/evaluate-handle (require-page!) expr arg))))\n\n;; =============================================================================\n;; Screenshots & PDF\n;; ============================================================================="} {:ns "spel", :name "evaluate-locator", :arglists "[sel expr] | [sel expr arg]", :doc "Evaluates JavaScript on the element found by this locator.", :lib-source "com.blockether.spel.locator/evaluate-locator", :wrapper-source "(defn sci-evaluate-locator\n  ([sel expr]     (throw-if-anomaly (locator/evaluate-locator (sci-$ sel) expr)))\n  ([sel expr arg] (throw-if-anomaly (locator/evaluate-locator (sci-$ sel) expr arg))))"} {:ns "spel", :name "expose-binding!", :arglists "[binding-name f]", :doc "Exposes a Clojure function as a binding.", :lib-source "com.blockether.spel.page/expose-binding!", :wrapper-source "(defn sci-expose-binding! [binding-name f]\n  (page/expose-binding! (require-page!) binding-name f))\n\n;; =============================================================================\n;; Page Events\n;; ============================================================================="} {:ns "spel", :name "expose-function!", :arglists "[fn-name f]", :doc "Exposes a Clojure function to JavaScript.", :lib-source "com.blockether.spel.page/expose-function!", :wrapper-source "(defn sci-expose-function! [fn-name f]\n  (page/expose-function! (require-page!) fn-name f))"} {:ns "spel", :name "fill", :arglists "[sel value] | [sel value opts]", :doc "Fills an input element with text.", :lib-source "com.blockether.spel.locator/fill", :wrapper-source "(defn sci-fill\n  ([sel value]      (throw-if-anomaly (locator/fill (sci-$ sel) value)))\n  ([sel value opts] (throw-if-anomaly (locator/fill (sci-$ sel) value opts))))"} {:ns "spel", :name "finish-video-recording", :arglists "[] | [opts]", :doc "Stops video recording by closing the context to finalize the video.", :lib-source "com.blockether.spel.core/video-path", :wrapper-source "(defn sci-finish-video-recording\n  \"Stops video recording by closing the context to finalize the video.\n   Returns the video file path. Creates a new context/page without video.\n\n   Opts:\n   :save-as - String. Copy video to this path before cleanup.\"\n  ([] (sci-finish-video-recording {}))\n  ([opts]\n   (let [pg      (require-page!)\n         video-path (core/video-path pg)\n         _       (when-let [save-path (:save-as opts)]\n                   (core/video-save-as! pg save-path))\n         ;; Close page first, then context to finalize video\n         _       (core/close-page! pg)\n         _       (when-let [c @!context] (core/close-context! c))\n         ;; Create fresh context without video\n         browser (require-browser!)\n         ctx     (core/new-context browser)\n         new-pg  (core/new-page-from-context ctx)]\n     (when-let [timeout @!default-timeout]\n       (page/set-default-timeout! new-pg timeout))\n     (reset! !context ctx)\n     (reset! !page new-pg)\n     {:status \"stopped\" :video-path video-path})))"} {:ns "spel", :name "first", :arglists "[sel]", :doc "Returns the first element matching the locator.", :lib-source "com.blockether.spel.locator/first-element", :wrapper-source "(defn sci-first            [sel] (locator/first-element (sci-$ sel)))"} {:ns "spel", :name "focus", :arglists "[sel]", :doc "Focuses the element.", :lib-source "com.blockether.spel.locator/focus", :wrapper-source "(defn sci-focus     [sel] (throw-if-anomaly (locator/focus (sci-$ sel))))"} {:ns "spel", :name "forward", :arglists "[]", :doc "Navigates forward in history.", :lib-source "com.blockether.spel.page/go-forward", :wrapper-source "(defn sci-forward   [] (throw-if-anomaly (page/go-forward (require-page!))))"} {:ns "spel", :name "frame-by-name", :arglists "[name]", :doc "Returns a frame by its name attribute.", :lib-source "com.blockether.spel.page/frame-by-name", :wrapper-source "(defn sci-frame-by-name [name] (page/frame-by-name (require-page!) name))"} {:ns "spel", :name "frame-by-url", :arglists "[pattern]", :doc "Returns a frame by matching URL pattern.", :lib-source "com.blockether.spel.page/frame-by-url", :wrapper-source "(defn sci-frame-by-url  [pattern] (page/frame-by-url (require-page!) pattern))\n\n;; =============================================================================\n;; Context & Browser Functions\n;; ============================================================================="} {:ns "spel", :name "frames", :arglists "[]", :doc "Returns all frames in the page.", :lib-source "com.blockether.spel.page/frames", :wrapper-source "(defn sci-frames      [] (page/frames (require-page!)))"} {:ns "spel", :name "full-snapshot", :arglists "[] | [page]", :doc "Captures a snapshot of the page and all its iframes.", :lib-source "com.blockether.spel.snapshot/capture-full-snapshot", :wrapper-source "(defn sci-full-snapshot\n  ([] (throw-if-anomaly (snapshot/capture-full-snapshot (require-page!))))\n  ([page] (throw-if-anomaly (snapshot/capture-full-snapshot page))))"} {:ns "spel", :name "goto", :arglists "[url] | [url opts]", :doc "Navigates the page to a URL.", :lib-source "com.blockether.spel.page/navigate", :wrapper-source "(defn sci-goto\n  ([url] (throw-if-anomaly (page/navigate (require-page!) url)))\n  ([url opts] (throw-if-anomaly (page/navigate (require-page!) url opts))))"} {:ns "spel", :name "help", :arglists "[] | [query]", :doc "Lists all available SCI eval functions with arglists and descriptions.", :wrapper-source "(defn sci-help\n  \"Lists all available SCI eval functions with arglists and descriptions.\n   Call with no args to see all namespaces summary.\n   Call with a namespace name to see all functions in that namespace.\n   Call with a search string to find matching functions.\"\n  ([]\n   (let [entries (load-help-registry)\n         by-ns (group-by :ns entries)]\n     (println \"spel eval — available namespaces:\\n\")\n     (doseq [[ns-name desc] (sort-by first help-ns-descriptions)]\n       (let [cnt (count (get by-ns ns-name []))]\n         (when (pos? cnt)\n           (println (str \"  \" (pad-right (str ns-name \"/\") 12) \" \"\n                      (pad-right (str cnt \" functions\") 16) \" \" desc)))))\n     (println)\n     (println \"Usage:\")\n     (println \"  (spel/help \\\"spel\\\")      — list all functions in spel/ namespace\")\n     (println \"  (spel/help \\\"click\\\")     — search for functions matching 'click'\")\n     (println \"  (spel/help \\\"spel/click\\\")— show details for specific function\"))\n   nil)\n  ([query]\n   (let [entries (load-help-registry)\n         query (str query)]\n     (cond\n        ;; Exact ns/fn match: \"spel/click\"\n       (str/includes? query \"/\")\n       (let [[ns-part fn-part] (str/split query #\"/\" 2)\n             matches (filter #(and (= (:ns %) ns-part)\n                                (= (:name %) fn-part))\n                       entries)]\n         (if (seq matches)\n           (doseq [{:keys [ns name arglists doc lib-source]} matches]\n             (println (str ns \"/\" name))\n             (println (str \"  Arglists: \" (if (str/blank? arglists) \"(none)\" arglists)))\n             (println (str \"  \" (if (str/blank? doc) \"(no description)\" doc)))\n             (when lib-source\n               (println (str \"  Source:   \" lib-source))))\n           (println (str \"No function found: \" query)))\n         nil)\n\n       ;; Exact namespace match\n       (some #(= query (:ns %)) entries)\n       (let [ns-entries (filter #(= (:ns %) query) entries)\n             desc (get help-ns-descriptions query \"\")]\n         (println (str query \"/ — \" desc \" (\" (count ns-entries) \" functions)\\n\"))\n         (println (format-help-table ns-entries))\n         nil)\n\n       ;; Search across all function names and docs\n       :else\n       (let [q (str/lower-case query)\n             matches (filter (fn [{:keys [ns name doc]}]\n                               (or (str/includes? (str/lower-case (str ns \"/\" name)) q)\n                                 (str/includes? (str/lower-case (str doc)) q)))\n                       entries)]\n         (if (seq matches)\n           (do\n             (println (str \"Found \" (count matches) \" match(es) for '\" query \"':\\n\"))\n             (println (format-help-table matches)))\n           (println (str \"No matches for '\" query \"'\")))\n         nil)))))"} {:ns "spel", :name "hidden?", :arglists "[sel]", :doc "Returns whether the element is hidden.", :lib-source "com.blockether.spel.locator/is-hidden?", :wrapper-source "(defn sci-hidden?    [sel] (locator/is-hidden? (sci-$ sel)))"} {:ns "spel", :name "highlight", :arglists "[sel]", :doc "Highlights the element for debugging.", :lib-source "com.blockether.spel.locator/highlight", :wrapper-source "(defn sci-highlight        [sel] (locator/highlight (sci-$ sel)))"} {:ns "spel", :name "hover", :arglists "[sel] | [sel opts]", :doc "Hovers over an element.", :lib-source "com.blockether.spel.locator/hover", :wrapper-source "(defn sci-hover\n  ([sel]      (throw-if-anomaly (locator/hover (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/hover (sci-$ sel) opts))))"} {:ns "spel", :name "html", :arglists "[]", :doc "Returns the full HTML content of the page.", :lib-source "com.blockether.spel.page/content", :wrapper-source "(defn sci-html      [] (page/content (require-page!)))\n\n;; =============================================================================\n;; Locators\n;; ============================================================================="} {:ns "spel", :name "info", :arglists "[]", :doc "Returns a map with current page :url, :title, :viewport, and :closed? state.", :lib-source "com.blockether.spel.page/url", :wrapper-source "(defn sci-info\n  \"Returns a map with current page :url, :title, :viewport, and :closed? state.\"\n  []\n  {:url      (page/url (require-page!))\n   :title    (page/title (require-page!))\n   :viewport (page/viewport-size (require-page!))\n   :closed?  (page/is-closed? (require-page!))})\n\n;; =============================================================================\n;; Help\n;; ============================================================================="} {:ns "spel", :name "inner-html", :arglists "[sel]", :doc "Returns the inner HTML of the element.", :lib-source "com.blockether.spel.locator/inner-html", :wrapper-source "(defn sci-inner-html [sel] (throw-if-anomaly (locator/inner-html (sci-$ sel))))"} {:ns "spel", :name "inner-text", :arglists "[sel]", :doc "Returns the inner text of the element.", :lib-source "com.blockether.spel.locator/inner-text", :wrapper-source "(defn sci-inner-text [sel] (throw-if-anomaly (locator/inner-text (sci-$ sel))))"} {:ns "spel", :name "keyboard", :arglists "[]", :doc "Returns the Keyboard for this page.", :lib-source "com.blockether.spel.page/page-keyboard", :wrapper-source "(defn sci-keyboard    [] (page/page-keyboard (require-page!)))"} {:ns "spel", :name "last", :arglists "[sel]", :doc "Returns the last element matching the locator.", :lib-source "com.blockether.spel.locator/last-element", :wrapper-source "(defn sci-last             [sel] (locator/last-element (sci-$ sel)))"} {:ns "spel", :name "last-response", :arglists "[url]", :doc "Navigates to URL and returns response info map with :status, :ok?, :url, :headers.", :lib-source "com.blockether.spel.page/navigate", :wrapper-source "(defn sci-last-response\n  \"Navigates to URL and returns response info map with :status, :ok?, :url, :headers.\"\n  [url]\n  (let [resp (throw-if-anomaly (page/navigate (require-page!) url))]\n    (when resp\n      {:status  (net/response-status resp)\n       :ok?     (net/response-ok? resp)\n       :url     (net/response-url resp)\n       :headers (net/response-headers resp)})))\n\n;; =============================================================================\n;; Info\n;; ============================================================================="} {:ns "spel", :name "loc-filter", :arglists "[sel opts]", :doc "Filters this locator to a narrower set.", :lib-source "com.blockether.spel.locator/loc-filter", :wrapper-source "(defn sci-loc-filter       [sel opts] (locator/loc-filter (sci-$ sel) opts))"} {:ns "spel", :name "loc-get-by-label", :arglists "[sel text]", :doc "Locates elements by label within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-label", :wrapper-source "(defn sci-loc-get-by-label   [sel text] (locator/loc-get-by-label (sci-$ sel) text))"} {:ns "spel", :name "loc-get-by-role", :arglists "[sel role]", :doc "Locates elements by ARIA role within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-role", :wrapper-source "(defn sci-loc-get-by-role    [sel role] (locator/loc-get-by-role (sci-$ sel) role))"} {:ns "spel", :name "loc-get-by-test-id", :arglists "[sel id]", :doc "Locates elements by test ID within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-test-id", :wrapper-source "(defn sci-loc-get-by-test-id [sel id] (locator/loc-get-by-test-id (sci-$ sel) id))\n\n;; =============================================================================\n;; Locator Waiting & Evaluation\n;; ============================================================================="} {:ns "spel", :name "loc-get-by-text", :arglists "[sel text]", :doc "Locates elements by text within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-text", :wrapper-source "(defn sci-loc-get-by-text    [sel text] (locator/loc-get-by-text (sci-$ sel) text))"} {:ns "spel", :name "loc-locator", :arglists "[sel sub-sel]", :doc "Creates a sub-locator within this locator.", :lib-source "com.blockether.spel.locator/loc-locator", :wrapper-source "(defn sci-loc-locator      [sel sub-sel] (locator/loc-locator (sci-$ sel) sub-sel))"} {:ns "spel", :name "loc-wait-for", :arglists "[sel] | [sel opts]", :doc "Waits for the locator to satisfy a condition.", :lib-source "com.blockether.spel.locator/wait-for", :wrapper-source "(defn sci-loc-wait-for\n  ([sel]      (throw-if-anomaly (locator/wait-for (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/wait-for (sci-$ sel) opts))))"} {:ns "spel", :name "locator-screenshot", :arglists "[sel] | [sel opts]", :doc "Takes a screenshot of the element.", :lib-source "com.blockether.spel.locator/locator-screenshot", :wrapper-source "(defn sci-locator-screenshot\n  ([sel]      (throw-if-anomaly (locator/locator-screenshot (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/locator-screenshot (sci-$ sel) opts))))\n\n;; =============================================================================\n;; Locator Content & State\n;; ============================================================================="} {:ns "spel", :name "main-frame", :arglists "[]", :doc "Returns the main frame of the page.", :lib-source "com.blockether.spel.page/main-frame", :wrapper-source "(defn sci-main-frame  [] (page/main-frame (require-page!)))"} {:ns "spel", :name "mark", :arglists "[& refs]", :doc "Highlights specific snapshot refs with prominent pre-action markers.", :lib-source "com.blockether.spel.annotate/inject-action-markers!", :wrapper-source "(defn sci-mark\n  \"Highlights specific snapshot refs with prominent pre-action markers.\n   Accepts ref strings with or without @ prefix.\"\n  [& refs]\n  (annotate/inject-action-markers! (require-page!) refs))"} {:ns "spel", :name "mouse", :arglists "[]", :doc "Returns the Mouse for this page.", :lib-source "com.blockether.spel.page/page-mouse", :wrapper-source "(defn sci-mouse       [] (page/page-mouse (require-page!)))"} {:ns "spel", :name "new-tab!", :arglists "[]", :doc "Opens a new tab in the current context and switches to it.", :lib-source "com.blockether.spel.core/new-page-from-context", :wrapper-source "(defn sci-new-tab!\n  \"Opens a new tab in the current context and switches to it.\"\n  []\n  (let [new-pg (core/new-page-from-context (require-context!))]\n    (reset! !page new-pg) new-pg))"} {:ns "spel", :name "nth", :arglists "[sel n]", :doc "Returns the nth element matching the locator.", :lib-source "com.blockether.spel.locator/nth-element", :wrapper-source "(defn sci-nth              [sel n] (locator/nth-element (sci-$ sel) n))"} {:ns "spel", :name "on-close", :arglists "[handler]", :doc "Registers a handler for page close.", :lib-source "com.blockether.spel.page/on-close", :wrapper-source "(defn sci-on-close     [handler] (page/on-close (require-page!) handler))"} {:ns "spel", :name "on-console", :arglists "[handler]", :doc "Registers a handler for console messages.", :lib-source "com.blockether.spel.page/on-console", :wrapper-source "(defn sci-on-console   [handler] (page/on-console (require-page!) handler))"} {:ns "spel", :name "on-dialog", :arglists "[handler]", :doc "Registers a handler for dialogs.", :lib-source "com.blockether.spel.page/on-dialog", :wrapper-source "(defn sci-on-dialog    [handler] (page/on-dialog (require-page!) handler))"} {:ns "spel", :name "on-download", :arglists "[handler]", :doc "Registers a handler for downloads.", :lib-source "com.blockether.spel.page/on-download", :wrapper-source "(defn sci-on-download  [handler] (page/on-download (require-page!) handler))"} {:ns "spel", :name "on-page-error", :arglists "[handler]", :doc "Registers a handler for page errors.", :lib-source "com.blockether.spel.page/on-page-error", :wrapper-source "(defn sci-on-page-error [handler] (page/on-page-error (require-page!) handler))"} {:ns "spel", :name "on-popup", :arglists "[handler]", :doc "Registers a handler for popup pages.", :lib-source "com.blockether.spel.page/on-popup", :wrapper-source "(defn sci-on-popup     [handler] (page/on-popup (require-page!) handler))\n\n;; =============================================================================\n;; Routing\n;; ============================================================================="} {:ns "spel", :name "on-request", :arglists "[handler]", :doc "Registers a handler for requests.", :lib-source "com.blockether.spel.page/on-request", :wrapper-source "(defn sci-on-request   [handler] (page/on-request (require-page!) handler))"} {:ns "spel", :name "on-response", :arglists "[handler]", :doc "Registers a handler for responses.", :lib-source "com.blockether.spel.page/on-response", :wrapper-source "(defn sci-on-response  [handler] (page/on-response (require-page!) handler))"} {:ns "spel", :name "once-dialog", :arglists "[handler]", :doc "Registers a one-time handler for the next dialog.", :lib-source "com.blockether.spel.page/once-dialog", :wrapper-source "(defn sci-once-dialog  [handler] (page/once-dialog (require-page!) handler))"} {:ns "spel", :name "page", :arglists "[]", :doc "Returns the current Page instance.", :wrapper-source "(defn sci-page\n  \"Returns the current Page instance.\"\n  [] (require-page!))"} {:ns "spel", :name "page-context", :arglists "[]", :doc "Returns the BrowserContext that the page belongs to.", :lib-source "com.blockether.spel.page/page-context", :wrapper-source "(defn sci-page-context [] (page/page-context (require-page!)))"} {:ns "spel", :name "pdf", :arglists "[] | [path-or-opts]", :doc "Generates a PDF of the page. Only works in Chromium headless.", :lib-source "com.blockether.spel.page/pdf", :wrapper-source "(defn sci-pdf\n  ([] (throw-if-anomaly (page/pdf (require-page!))))\n  ([path-or-opts]\n   (throw-if-anomaly\n     (if (string? path-or-opts)\n       (page/pdf (require-page!) {:path path-or-opts})\n       (page/pdf (require-page!) path-or-opts)))))\n\n;; =============================================================================\n;; Waiting\n;; ============================================================================="} {:ns "spel", :name "press", :arglists "[sel key] | [sel key opts]", :doc "Presses a key or key combination.", :lib-source "com.blockether.spel.locator/press", :wrapper-source "(defn sci-press\n  ([sel key]      (throw-if-anomaly (locator/press (sci-$ sel) key)))\n  ([sel key opts] (throw-if-anomaly (locator/press (sci-$ sel) key opts))))"} {:ns "spel", :name "reload!", :arglists "[]", :doc "Reloads the page.", :lib-source "com.blockether.spel.page/reload", :wrapper-source "(defn sci-reload!   [] (throw-if-anomaly (page/reload (require-page!))))"} {:ns "spel", :name "resolve-ref", :arglists "[ref-id]", :doc "Resolves a ref ID to a Playwright Locator.", :lib-source "com.blockether.spel.snapshot/resolve-ref", :wrapper-source "(defn sci-resolve-ref [ref-id]\n  (snapshot/resolve-ref (require-page!) ref-id))"} {:ns "spel", :name "restart!", :arglists "[] | [opts]", :doc "Stops the current session and starts a new one with the given options.", :wrapper-source "(defn sci-restart!\n  \"Stops the current session and starts a new one with the given options.\"\n  ([] (sci-restart! {}))\n  ([opts] (when @!pw (sci-stop!)) (sci-start! opts)))\n\n;; Tab management"} {:ns "spel", :name "route!", :arglists "[pattern handler]", :doc "Registers a route handler for URL pattern.", :lib-source "com.blockether.spel.page/route!", :wrapper-source "(defn sci-route!   [pattern handler] (page/route! (require-page!) pattern handler))"} {:ns "spel", :name "route-from-har!", :arglists "[har] | [har opts]", :doc "Routes requests from a HAR file. Replays recorded responses for matching requests.", :lib-source "com.blockether.spel.page/route-from-har!", :wrapper-source "(defn sci-route-from-har!\n  ([har]      (throw-if-anomaly (page/route-from-har! (require-page!) har)))\n  ([har opts] (throw-if-anomaly (page/route-from-har! (require-page!) har opts))))"} {:ns "spel", :name "route-web-socket!", :arglists "[pattern handler]", :doc "Registers a handler for WebSocket connections matching a URL pattern.", :lib-source "com.blockether.spel.page/route-web-socket!", :wrapper-source "(defn sci-route-web-socket! [pattern handler]\n  (page/route-web-socket! (require-page!) pattern handler))\n\n;; =============================================================================\n;; Page Accessors\n;; ============================================================================="} {:ns "spel", :name "save-annotated-screenshot!", :arglists "[refs path] | [refs path opts]", :doc "Takes an annotated screenshot and saves it to a file.", :lib-source "com.blockether.spel.annotate/save-annotated-screenshot!", :wrapper-source "(defn sci-save-annotated-screenshot!\n  ([refs path] (throw-if-anomaly (annotate/save-annotated-screenshot! (require-page!) refs path)))\n  ([refs path opts] (throw-if-anomaly (annotate/save-annotated-screenshot! (require-page!) refs path opts))))\n\n;; Pre-action markers"} {:ns "spel", :name "save-audit-screenshot!", :arglists "[caption path] | [caption path opts]", :doc "Takes an audit screenshot and saves it to a file.", :lib-source "com.blockether.spel.annotate/save-audit-screenshot!", :wrapper-source "(defn sci-save-audit-screenshot!\n  \"Takes an audit screenshot and saves it to a file.\"\n  ([caption path] (throw-if-anomaly (annotate/save-audit-screenshot! (require-page!) caption path)))\n  ([caption path opts] (throw-if-anomaly (annotate/save-audit-screenshot! (require-page!) caption path opts))))\n\n;; Report builder (polymorphic entries -> HTML / PDF)"} {:ns "spel", :name "screenshot", :arglists "[] | [path-or-opts]", :doc "Takes a screenshot of the page.", :lib-source "com.blockether.spel.page/screenshot", :wrapper-source "(defn sci-screenshot\n  ([] (throw-if-anomaly (page/screenshot (require-page!))))\n  ([path-or-opts]\n   (throw-if-anomaly\n     (if (string? path-or-opts)\n       (page/screenshot (require-page!) {:path path-or-opts})\n       (page/screenshot (require-page!) path-or-opts)))))"} {:ns "spel", :name "scroll-into-view", :arglists "[sel]", :doc "Scrolls element into view.", :lib-source "com.blockether.spel.locator/scroll-into-view", :wrapper-source "(defn sci-scroll-into-view [sel] (throw-if-anomaly (locator/scroll-into-view (sci-$ sel))))"} {:ns "spel", :name "select", :arglists "[sel values]", :doc "Selects options in a select element.", :lib-source "com.blockether.spel.locator/select-option", :wrapper-source "(defn sci-select    [sel values] (throw-if-anomaly (locator/select-option (sci-$ sel) values)))"} {:ns "spel", :name "set-assertion-timeout!", :arglists "[ms]", :doc "Sets the default timeout for all assertions.", :lib-source "com.blockether.spel.assertions/set-default-assertion-timeout!", :wrapper-source "(defn sci-set-assertion-timeout! [ms] (assert/set-default-assertion-timeout! ms))\n\n;; Locator text assertions"} {:ns "spel", :name "set-content!", :arglists "[html] | [html opts]", :doc "Sets the HTML content of the page.", :lib-source "com.blockether.spel.page/set-content!", :wrapper-source "(defn sci-set-content!\n  ([html]      (throw-if-anomaly (page/set-content! (require-page!) html)))\n  ([html opts] (throw-if-anomaly (page/set-content! (require-page!) html opts))))"} {:ns "spel", :name "set-default-navigation-timeout!", :arglists "[ms]", :doc "Sets the default navigation timeout.", :lib-source "com.blockether.spel.page/set-default-navigation-timeout!", :wrapper-source "(defn sci-set-default-navigation-timeout! [ms]\n  (page/set-default-navigation-timeout! (require-page!) ms))"} {:ns "spel", :name "set-default-timeout!", :arglists "[ms]", :doc "Sets the default timeout for page operations.", :lib-source "com.blockether.spel.page/set-default-timeout!", :wrapper-source "(defn sci-set-page-default-timeout! [ms]\n  (page/set-default-timeout! (require-page!) ms))"} {:ns "spel", :name "set-extra-http-headers!", :arglists "[headers]", :doc "Sets extra HTTP headers for all requests on this page.", :lib-source "com.blockether.spel.page/set-extra-http-headers!", :wrapper-source "(defn sci-set-extra-http-headers! [headers]\n  (page/set-extra-http-headers! (require-page!) headers))"} {:ns "spel", :name "set-input-files!", :arglists "[sel files]", :doc "Sets the value of a file input element.", :lib-source "com.blockether.spel.locator/set-input-files!", :wrapper-source "(defn sci-set-input-files! [sel files] (throw-if-anomaly (locator/set-input-files! (sci-$ sel) files)))"} {:ns "spel", :name "set-viewport-size!", :arglists "[width height]", :doc "Sets the viewport size.", :lib-source "com.blockether.spel.page/set-viewport-size!", :wrapper-source "(defn sci-set-viewport-size! [width height]\n  (page/set-viewport-size! (require-page!) width height))"} {:ns "spel", :name "sleep", :arglists "[ms]", :doc "Waits for the specified time in milliseconds.", :lib-source "com.blockether.spel.page/wait-for-timeout", :wrapper-source "(defn sci-sleep [ms] (page/wait-for-timeout (require-page!) ms))"} {:ns "spel", :name "snapshot", :arglists "[] | [page-or-opts] | [page opts]", :doc "Captures an accessibility snapshot of the page with numbered refs.", :lib-source "com.blockether.spel.snapshot/capture-snapshot", :wrapper-source "(defn sci-snapshot\n  ([] (throw-if-anomaly (snapshot/capture-snapshot (require-page!))))\n  ([page-or-opts]\n   (if (map? page-or-opts)\n     (throw-if-anomaly (snapshot/capture-snapshot (require-page!) page-or-opts))\n     (throw-if-anomaly (snapshot/capture-snapshot page-or-opts))))\n  ([page opts] (throw-if-anomaly (snapshot/capture-snapshot page opts))))"} {:ns "spel", :name "source", :arglists "[query]", :doc "Shows the source code of a SCI eval function.", :wrapper-source "(defn sci-source\n  \"Shows the source code of a SCI eval function.\n   Accepts 'ns/fn' format (e.g. 'spel/click') or bare function name to search.\"\n  [query]\n  (let [entries (load-help-registry)\n        query (str query)]\n    (if (str/includes? query \"/\")\n      ;; Exact ns/fn match\n      (let [[ns-part fn-part] (str/split query #\"/\" 2)\n            matches (filter #(and (= (:ns %) ns-part)\n                               (= (:name %) fn-part))\n                      entries)]\n        (if (seq matches)\n          (doseq [{:keys [ns name doc lib-source wrapper-source]} matches]\n            (println (str \";; \" ns \"/\" name))\n            (println (str \";; \" (if (str/blank? doc) \"(no description)\" doc)))\n            (when lib-source\n              (println (str \";; Delegates to: \" lib-source)))\n            (println)\n            (if wrapper-source\n              (println wrapper-source)\n              (println \";; (inline function — no separate source)\")))\n          (println (str \"No function found: \" query))))\n      ;; Search by name\n      (let [q (str/lower-case query)\n            matches (filter (fn [{:keys [name]}]\n                              (str/includes? (str/lower-case name) q))\n                      entries)]\n        (cond\n          (empty? matches)\n          (println (str \"No matches for '\" query \"'\"))\n\n          (= 1 (count matches))\n          (let [{:keys [ns name doc lib-source wrapper-source]} (first matches)]\n            (println (str \";; \" ns \"/\" name))\n            (println (str \";; \" (if (str/blank? doc) \"(no description)\" doc)))\n            (when lib-source\n              (println (str \";; Delegates to: \" lib-source)))\n            (println)\n            (if wrapper-source\n              (println wrapper-source)\n              (println \";; (inline function — no separate source)\")))\n\n          :else\n          (do\n            (println (str \"Multiple matches for '\" query \"' — be more specific:\\n\"))\n            (doseq [{:keys [ns name]} matches]\n              (println (str \"  \" ns \"/\" name)))))))\n    nil))\n\n;; =============================================================================\n;; Snapshot + Annotate\n;; ============================================================================="} {:ns "spel", :name "start!", :arglists "[] | [opts]", :doc "Creates a new Playwright instance.", :lib-source "com.blockether.spel.core/create", :wrapper-source "(defn sci-start!\n  ([] (sci-start! {}))\n  ([opts]\n   ;; In daemon mode, the browser is already running — start! is a no-op.\n   ;; This lets old scripts that call (spel/start!) work unchanged.\n   (if @!page\n     :started\n     (do\n       (when @!pw\n         (throw (ex-info \"Session already running. Call (spel/stop!) first.\" {})))\n       (let [pw-inst      (core/create)\n             launch-opts  (cond-> {:headless (get opts :headless true)}\n                            (:slow-mo opts) (assoc :slow-mo (:slow-mo opts)))\n             browser-type (get opts :browser :chromium)\n             browser-inst (case browser-type\n                            :chromium (core/launch-chromium pw-inst launch-opts)\n                            :firefox  (core/launch-firefox pw-inst launch-opts)\n                            :webkit   (core/launch-webkit pw-inst launch-opts))\n             ctx-opts     (cond-> {}\n                            (:viewport opts)    (assoc :viewport (:viewport opts))\n                            (:base-url opts)    (assoc :base-url (:base-url opts))\n                            (:user-agent opts)  (assoc :user-agent (:user-agent opts))\n                            (:locale opts)      (assoc :locale (:locale opts))\n                            (:timezone-id opts) (assoc :timezone-id (:timezone-id opts)))\n             ctx          (core/new-context browser-inst (when (seq ctx-opts) ctx-opts))\n             pg-inst      (core/new-page-from-context ctx)]\n         ;; Set default action timeout: explicit opts > --timeout flag > Playwright default\n         (when-let [timeout (or (:timeout opts) @!default-timeout)]\n           (page/set-default-timeout! pg-inst timeout))\n         (reset! !pw pw-inst)\n         (reset! !browser browser-inst)\n         (reset! !context ctx)\n         (reset! !page pg-inst)\n         :started)))))"} {:ns "spel", :name "start-video-recording", :arglists "[] | [opts]", :doc "Starts video recording by creating a new context with video recording enabled.", :lib-source "com.blockether.spel.core/close-page!", :wrapper-source "(defn sci-start-video-recording\n  \"Starts video recording by creating a new context with video recording enabled.\n   Closes the current context/page and creates new ones with video.\n\n   Opts:\n   :video-dir  - String. Directory for video files (default: \\\"videos\\\").\n   :video-size - Map with :width :height (default: 1280x720).\"\n  ([] (sci-start-video-recording {}))\n  ([opts]\n   (let [video-dir  (or (:video-dir opts) \"videos\")\n         video-size (or (:video-size opts) {:width 1280 :height 720})\n         browser    (require-browser!)\n         ;; Close existing context if any\n         _          (when-let [p @!page] (try (core/close-page! p) (catch Exception _)))\n         _          (when-let [c @!context] (try (core/close-context! c) (catch Exception _)))\n         ctx-opts   {:record-video-dir  video-dir\n                     :record-video-size video-size}\n         ctx        (core/new-context browser ctx-opts)\n         pg         (core/new-page-from-context ctx)]\n     (when-let [timeout @!default-timeout]\n       (page/set-default-timeout! pg timeout))\n     (reset! !context ctx)\n     (reset! !page pg)\n     {:status \"recording\" :video-dir video-dir})))"} {:ns "spel", :name "stop!", :arglists "[]", :doc "Stops the Playwright session, closing browser and cleaning up resources.", :wrapper-source "(defn sci-stop!\n  \"Stops the Playwright session, closing browser and cleaning up resources.\"\n  []\n  ;; In daemon mode, the daemon owns the browser — just nil the SCI atoms.\n  (if @!daemon-mode?\n    (do (reset! !page nil) (reset! !context nil)\n      (reset! !browser nil) (reset! !pw nil)\n      :stopped)\n    (do\n      ;; Close top-down: browser cleans up all contexts/pages, playwright shuts down node.\n      ;; No need to individually close page/context — they're owned by the browser.\n      (when-let [b @!browser]\n        (try (core/close-browser! b)\n          (catch Exception e\n            (binding [*out* *err*]\n              (println (str \"spel: warn: close-browser failed: \" (.getMessage e)))))))\n      (when-let [p @!pw]\n        (try (core/close! p)\n          (catch Exception e\n            (binding [*out* *err*]\n              (println (str \"spel: warn: close-playwright failed: \" (.getMessage e)))))))\n      (reset! !page nil) (reset! !context nil)\n      (reset! !browser nil) (reset! !pw nil)\n      :stopped)))"} {:ns "spel", :name "switch-tab!", :arglists "[idx]", :doc "Switches to the tab at the given index.", :lib-source "com.blockether.spel.core/context-pages", :wrapper-source "(defn sci-switch-tab!\n  \"Switches to the tab at the given index.\"\n  [idx]\n  (let [pages (core/context-pages (require-context!))\n        pg-inst (nth pages idx)]\n    (reset! !page pg-inst) pg-inst))"} {:ns "spel", :name "tabs", :arglists "[]", :doc "Returns a list of all open tabs with their index, url, title, and active status.", :lib-source "com.blockether.spel.core/context-pages", :wrapper-source "(defn sci-tabs\n  \"Returns a list of all open tabs with their index, url, title, and active status.\"\n  []\n  (let [pages (core/context-pages (require-context!))\n        active @!page]\n    (mapv (fn [idx pg-inst]\n            {:index idx :url (page/url pg-inst)\n             :title (page/title pg-inst) :active? (= pg-inst active)})\n      (range) pages)))\n\n;; =============================================================================\n;; Navigation\n;; ============================================================================="} {:ns "spel", :name "tap", :arglists "[sel]", :doc "Taps an element (for touch devices).", :lib-source "com.blockether.spel.locator/tap-element", :wrapper-source "(defn sci-tap       [sel] (throw-if-anomaly (locator/tap-element (sci-$ sel))))"} {:ns "spel", :name "text", :arglists "[sel]", :doc "Returns the text content of the element.", :lib-source "com.blockether.spel.locator/text-content", :wrapper-source "(defn sci-text       [sel] (throw-if-anomaly (locator/text-content (sci-$ sel))))"} {:ns "spel", :name "title", :arglists "[]", :doc "Returns the page title.", :lib-source "com.blockether.spel.page/title", :wrapper-source "(defn sci-title     [] (page/title (require-page!)))"} {:ns "spel", :name "touchscreen", :arglists "[]", :doc "Returns the Touchscreen for this page.", :lib-source "com.blockether.spel.page/page-touchscreen", :wrapper-source "(defn sci-touchscreen [] (page/page-touchscreen (require-page!)))"} {:ns "spel", :name "trace-group", :arglists "[name]", :doc "Opens a named group in the trace. Groups nest actions visually in Trace Viewer.", :wrapper-source "(defn sci-trace-group\n  \"Opens a named group in the trace. Groups nest actions visually in Trace Viewer.\"\n  [name]\n  (.group ^com.microsoft.playwright.Tracing (util/context-tracing (require-context!)) ^String name))"} {:ns "spel", :name "trace-group-end", :arglists "[]", :doc "Closes the current trace group.", :wrapper-source "(defn sci-trace-group-end\n  \"Closes the current trace group.\"\n  []\n  (.groupEnd ^com.microsoft.playwright.Tracing (util/context-tracing (require-context!))))\n\n;; =============================================================================\n;; Video Recording\n;; ============================================================================="} {:ns "spel", :name "trace-start!", :arglists "[] | [opts]", :doc "Starts Playwright tracing on the current context.", :wrapper-source "(defn sci-trace-start!\n  \"Starts Playwright tracing on the current context.\n\n   Opts:\n   :name        - String. Trace name (appears in Trace Viewer).\n   :screenshots - Boolean. Capture screenshots (default: false).\n   :snapshots   - Boolean. Capture DOM snapshots (default: false).\n   :sources     - Boolean. Include source files (default: false).\"\n  ([]     (throw-if-anomaly (util/tracing-start! (util/context-tracing (require-context!)))))\n  ([opts] (throw-if-anomaly (util/tracing-start! (util/context-tracing (require-context!)) opts))))"} {:ns "spel", :name "trace-stop!", :arglists "[] | [opts]", :doc "Stops Playwright tracing and saves to a file.", :wrapper-source "(defn sci-trace-stop!\n  \"Stops Playwright tracing and saves to a file.\n\n   Opts:\n   :path - String. Output path (default: \\\"trace.zip\\\").\"\n  ([]     (throw-if-anomaly (util/tracing-stop! (util/context-tracing (require-context!)))))\n  ([opts] (throw-if-anomaly (util/tracing-stop! (util/context-tracing (require-context!)) opts))))"} {:ns "spel", :name "type-text", :arglists "[sel text] | [sel text opts]", :doc "Types text into an element character by character.", :lib-source "com.blockether.spel.locator/type-text", :wrapper-source "(defn sci-type-text\n  ([sel text]      (throw-if-anomaly (locator/type-text (sci-$ sel) text)))\n  ([sel text opts] (throw-if-anomaly (locator/type-text (sci-$ sel) text opts))))"} {:ns "spel", :name "unannotate", :arglists "[]", :doc "Removes all annotation overlays from the current page.", :lib-source "com.blockether.spel.annotate/remove-overlays!", :wrapper-source "(defn sci-unannotate\n  \"Removes all annotation overlays from the current page.\"\n  [] (annotate/remove-overlays! (require-page!)))"} {:ns "spel", :name "uncheck", :arglists "[sel] | [sel opts]", :doc "Unchecks a checkbox.", :lib-source "com.blockether.spel.locator/uncheck", :wrapper-source "(defn sci-uncheck\n  ([sel]      (throw-if-anomaly (locator/uncheck (sci-$ sel))))\n  ([sel opts] (throw-if-anomaly (locator/uncheck (sci-$ sel) opts))))"} {:ns "spel", :name "unmark", :arglists "[]", :doc "Removes all pre-action markers from the current page.", :lib-source "com.blockether.spel.annotate/remove-action-markers!", :wrapper-source "(defn sci-unmark\n  \"Removes all pre-action markers from the current page.\"\n  [] (annotate/remove-action-markers! (require-page!)))\n\n;; Audit screenshots"} {:ns "spel", :name "unroute!", :arglists "[pattern]", :doc "Removes a route handler.", :lib-source "com.blockether.spel.page/unroute!", :wrapper-source "(defn sci-unroute! [pattern]         (page/unroute! (require-page!) pattern))"} {:ns "spel", :name "url", :arglists "[]", :doc "Returns the current page URL.", :lib-source "com.blockether.spel.page/url", :wrapper-source "(defn sci-url       [] (page/url (require-page!)))"} {:ns "spel", :name "value", :arglists "[sel]", :doc "Returns the input value of an input element.", :lib-source "com.blockether.spel.locator/input-value", :wrapper-source "(defn sci-value      [sel] (throw-if-anomaly (locator/input-value (sci-$ sel))))"} {:ns "spel", :name "video-path", :arglists "[]", :doc "Returns the video file path for the current page, or nil if not recording.", :lib-source "com.blockether.spel.core/video-path", :wrapper-source "(defn sci-video-path\n  \"Returns the video file path for the current page, or nil if not recording.\"\n  []\n  (core/video-path (require-page!)))\n\n;; =============================================================================\n;; Network\n;; ============================================================================="} {:ns "spel", :name "visible?", :arglists "[sel]", :doc "Returns whether the element is visible.", :lib-source "com.blockether.spel.locator/is-visible?", :wrapper-source "(defn sci-visible?   [sel] (locator/is-visible? (sci-$ sel)))"} {:ns "spel", :name "wait-for", :arglists "[sel] | [sel opts]", :doc "Waits for a selector to satisfy a condition.", :lib-source "com.blockether.spel.page/wait-for-selector", :wrapper-source "(defn sci-wait-for\n  ([sel]      (throw-if-anomaly (page/wait-for-selector (require-page!) sel)))\n  ([sel opts] (throw-if-anomaly (page/wait-for-selector (require-page!) sel opts))))"} {:ns "spel", :name "wait-for-download", :arglists "[action] | [action opts]", :doc "Waits for a download to start while executing `action`.", :lib-source "com.blockether.spel.page/wait-for-download", :wrapper-source "(defn sci-wait-for-download\n  ([action]      (page/wait-for-download (require-page!) action))\n  ([action opts] (page/wait-for-download (require-page!) action opts)))"} {:ns "spel", :name "wait-for-file-chooser", :arglists "[action] | [action opts]", :doc "Waits for a file chooser dialog while executing `action`.", :lib-source "com.blockether.spel.page/wait-for-file-chooser", :wrapper-source "(defn sci-wait-for-file-chooser\n  ([action]      (page/wait-for-file-chooser (require-page!) action))\n  ([action opts] (page/wait-for-file-chooser (require-page!) action opts)))\n\n;; =============================================================================\n;; Assertions (FIXED: all use assert/assert-that for proper type coercion)\n;; =============================================================================\n\n;; Entry points"} {:ns "spel", :name "wait-for-function", :arglists "[expr]", :doc "Waits for a JavaScript function to return a truthy value.", :lib-source "com.blockether.spel.page/wait-for-function", :wrapper-source "(defn sci-wait-for-function [expr] (throw-if-anomaly (page/wait-for-function (require-page!) expr)))"} {:ns "spel", :name "wait-for-load", :arglists "[] | [state]", :doc "Waits for the page to reach a load state.", :lib-source "com.blockether.spel.page/wait-for-load-state", :wrapper-source "(defn sci-wait-for-load\n  ([]      (throw-if-anomaly (page/wait-for-load-state (require-page!))))\n  ([state] (throw-if-anomaly (page/wait-for-load-state (require-page!) state))))"} {:ns "spel", :name "wait-for-popup", :arglists "[action] | [action opts]", :doc "Waits for a popup page to open while executing `action`.", :lib-source "com.blockether.spel.page/wait-for-popup", :wrapper-source "(defn sci-wait-for-popup\n  ([action]      (page/wait-for-popup (require-page!) action))\n  ([action opts] (page/wait-for-popup (require-page!) action opts)))"} {:ns "spel", :name "wait-for-url", :arglists "[url]", :doc "Waits for the page to navigate to a URL.", :lib-source "com.blockether.spel.page/wait-for-url", :wrapper-source "(defn sci-wait-for-url [url] (throw-if-anomaly (page/wait-for-url (require-page!) url)))"} {:ns "snapshot", :name "capture", :arglists "[] | [page-or-opts] | [page opts]", :doc "Captures an accessibility snapshot of the page with numbered refs.", :lib-source "com.blockether.spel.snapshot/capture-snapshot", :wrapper-source "(defn sci-snapshot\n  ([] (throw-if-anomaly (snapshot/capture-snapshot (require-page!))))\n  ([page-or-opts]\n   (if (map? page-or-opts)\n     (throw-if-anomaly (snapshot/capture-snapshot (require-page!) page-or-opts))\n     (throw-if-anomaly (snapshot/capture-snapshot page-or-opts))))\n  ([page opts] (throw-if-anomaly (snapshot/capture-snapshot page opts))))"} {:ns "snapshot", :name "capture-full", :arglists "[] | [page]", :doc "Captures a snapshot of the page and all its iframes.", :lib-source "com.blockether.spel.snapshot/capture-full-snapshot", :wrapper-source "(defn sci-full-snapshot\n  ([] (throw-if-anomaly (snapshot/capture-full-snapshot (require-page!))))\n  ([page] (throw-if-anomaly (snapshot/capture-full-snapshot page))))"} {:ns "snapshot", :name "clear-refs!", :arglists "[]", :doc "Removes all data-pw-ref attributes from the page.", :lib-source "com.blockether.spel.snapshot/clear-refs!", :wrapper-source "(defn sci-clear-refs! []\n  (snapshot/clear-refs! (require-page!)))"} {:ns "snapshot", :name "ref-bounding-box", :arglists "[refs ref-id]", :doc "Returns the bounding box for a ref from the last snapshot.", :lib-source "com.blockether.spel.snapshot/ref-bounding-box"} {:ns "snapshot", :name "resolve-ref", :arglists "[ref-id]", :doc "Resolves a ref ID to a Playwright Locator.", :lib-source "com.blockether.spel.snapshot/resolve-ref", :wrapper-source "(defn sci-resolve-ref [ref-id]\n  (snapshot/resolve-ref (require-page!) ref-id))"} {:ns "annotate", :name "annotated-screenshot", :arglists "[refs] | [refs opts]", :doc "Takes a screenshot with annotation overlays (convenience function).", :lib-source "com.blockether.spel.annotate/annotated-screenshot", :wrapper-source "(defn sci-annotated-screenshot\n  ([refs] (throw-if-anomaly (annotate/annotated-screenshot (require-page!) refs)))\n  ([refs opts] (throw-if-anomaly (annotate/annotated-screenshot (require-page!) refs opts))))"} {:ns "annotate", :name "audit-screenshot", :arglists "[caption] | [caption opts]", :doc "Takes a screenshot with a caption bar at the bottom.", :lib-source "com.blockether.spel.annotate/audit-screenshot", :wrapper-source "(defn sci-audit-screenshot\n  \"Takes a screenshot with a caption bar at the bottom.\"\n  ([caption] (throw-if-anomaly (annotate/audit-screenshot (require-page!) caption)))\n  ([caption opts] (throw-if-anomaly (annotate/audit-screenshot (require-page!) caption opts))))"} {:ns "annotate", :name "mark!", :arglists "[& refs]", :doc "Highlights specific snapshot refs with prominent pre-action markers.", :lib-source "com.blockether.spel.annotate/inject-action-markers!", :wrapper-source "(defn sci-mark\n  \"Highlights specific snapshot refs with prominent pre-action markers.\n   Accepts ref strings with or without @ prefix.\"\n  [& refs]\n  (annotate/inject-action-markers! (require-page!) refs))"} {:ns "annotate", :name "save!", :arglists "[refs path] | [refs path opts]", :doc "Takes an annotated screenshot and saves it to a file.", :lib-source "com.blockether.spel.annotate/save-annotated-screenshot!", :wrapper-source "(defn sci-save-annotated-screenshot!\n  ([refs path] (throw-if-anomaly (annotate/save-annotated-screenshot! (require-page!) refs path)))\n  ([refs path opts] (throw-if-anomaly (annotate/save-annotated-screenshot! (require-page!) refs path opts))))\n\n;; Pre-action markers"} {:ns "annotate", :name "save-audit!", :arglists "[caption path] | [caption path opts]", :doc "Takes an audit screenshot and saves it to a file.", :lib-source "com.blockether.spel.annotate/save-audit-screenshot!", :wrapper-source "(defn sci-save-audit-screenshot!\n  \"Takes an audit screenshot and saves it to a file.\"\n  ([caption path] (throw-if-anomaly (annotate/save-audit-screenshot! (require-page!) caption path)))\n  ([caption path opts] (throw-if-anomaly (annotate/save-audit-screenshot! (require-page!) caption path opts))))\n\n;; Report builder (polymorphic entries -> HTML / PDF)"} {:ns "annotate", :name "unmark!", :arglists "[]", :doc "Removes all pre-action markers from the current page.", :lib-source "com.blockether.spel.annotate/remove-action-markers!", :wrapper-source "(defn sci-unmark\n  \"Removes all pre-action markers from the current page.\"\n  [] (annotate/remove-action-markers! (require-page!)))\n\n;; Audit screenshots"} {:ns "input", :name "key-down", :arglists "[keyboard key]", :doc "Dispatches a keydown event.", :lib-source "com.blockether.spel.input/key-down"} {:ns "input", :name "key-insert-text", :arglists "[keyboard text]", :doc "Inserts text without key events.", :lib-source "com.blockether.spel.input/key-insert-text"} {:ns "input", :name "key-press", :arglists "[keyboard key] | [keyboard key press-opts]", :doc "Presses a key on the keyboard.", :lib-source "com.blockether.spel.input/key-press"} {:ns "input", :name "key-type", :arglists "[keyboard text] | [keyboard text type-opts]", :doc "Types text character by character.", :lib-source "com.blockether.spel.input/key-type"} {:ns "input", :name "key-up", :arglists "[keyboard key]", :doc "Dispatches a keyup event.", :lib-source "com.blockether.spel.input/key-up"} {:ns "input", :name "mouse-click", :arglists "[mouse x y] | [mouse x y click-opts]", :doc "Clicks at the given coordinates.", :lib-source "com.blockether.spel.input/mouse-click"} {:ns "input", :name "mouse-dblclick", :arglists "[mouse x y] | [mouse x y dblclick-opts]", :doc "Double-clicks at the given coordinates.", :lib-source "com.blockether.spel.input/mouse-dblclick"} {:ns "input", :name "mouse-down", :arglists "[mouse]", :doc "Dispatches a mousedown event.", :lib-source "com.blockether.spel.input/mouse-down"} {:ns "input", :name "mouse-move", :arglists "[mouse x y] | [mouse x y move-opts]", :doc "Moves the mouse to the given coordinates.", :lib-source "com.blockether.spel.input/mouse-move"} {:ns "input", :name "mouse-up", :arglists "[mouse]", :doc "Dispatches a mouseup event.", :lib-source "com.blockether.spel.input/mouse-up"} {:ns "input", :name "mouse-wheel", :arglists "[mouse delta-x delta-y]", :doc "Dispatches a wheel event.", :lib-source "com.blockether.spel.input/mouse-wheel"} {:ns "input", :name "touchscreen-tap", :arglists "[ts x y]", :doc "Taps at the given coordinates.", :lib-source "com.blockether.spel.input/touchscreen-tap"} {:ns "frame", :name "child-frames", :arglists "[frame]", :doc "Returns child frames.", :lib-source "com.blockether.spel.frame/child-frames"} {:ns "frame", :name "content", :arglists "[frame]", :doc "Returns the HTML content of the frame.", :lib-source "com.blockether.spel.frame/frame-content"} {:ns "frame", :name "evaluate", :arglists "[frame expression] | [frame expression arg]", :doc "Evaluates JavaScript in the frame context.", :lib-source "com.blockether.spel.frame/frame-evaluate"} {:ns "frame", :name "fl-first", :arglists "[fl]", :doc "Returns the first FrameLocator.", :lib-source "com.blockether.spel.frame/fl-first"} {:ns "frame", :name "fl-get-by-label", :arglists "[fl text]", :doc "Locates by label within a FrameLocator.", :lib-source "com.blockether.spel.frame/fl-get-by-label"} {:ns "frame", :name "fl-get-by-role", :arglists "[fl role]", :doc "Locates by ARIA role within a FrameLocator.", :lib-source "com.blockether.spel.frame/fl-get-by-role"} {:ns "frame", :name "fl-get-by-text", :arglists "[fl text]", :doc "Locates by text within a FrameLocator.", :lib-source "com.blockether.spel.frame/fl-get-by-text"} {:ns "frame", :name "fl-last", :arglists "[fl]", :doc "Returns the last FrameLocator.", :lib-source "com.blockether.spel.frame/fl-last"} {:ns "frame", :name "fl-locator", :arglists "[fl selector]", :doc "Creates a Locator within a FrameLocator.", :lib-source "com.blockether.spel.frame/fl-locator"} {:ns "frame", :name "fl-nth", :arglists "[fl index]", :doc "Returns the nth FrameLocator.", :lib-source "com.blockether.spel.frame/fl-nth"} {:ns "frame", :name "frame-locator", :arglists "[page-or-frame selector]", :doc "Creates a FrameLocator for an iframe.", :lib-source "com.blockether.spel.frame/frame-locator-obj"} {:ns "frame", :name "frame-page", :arglists "[frame]", :doc "Returns the page that owns this frame.", :lib-source "com.blockether.spel.frame/frame-page"} {:ns "frame", :name "get-by-label", :arglists "[frame text]", :doc "Locates elements by label in the frame.", :lib-source "com.blockether.spel.frame/frame-get-by-label"} {:ns "frame", :name "get-by-role", :arglists "[frame role]", :doc "Locates elements by ARIA role in the frame.", :lib-source "com.blockether.spel.frame/frame-get-by-role"} {:ns "frame", :name "get-by-test-id", :arglists "[frame test-id]", :doc "Locates elements by test ID in the frame.", :lib-source "com.blockether.spel.frame/frame-get-by-test-id"} {:ns "frame", :name "get-by-text", :arglists "[frame text]", :doc "Locates elements by text in the frame.", :lib-source "com.blockether.spel.frame/frame-get-by-text"} {:ns "frame", :name "is-detached?", :arglists "[frame]", :doc "Returns whether the frame has been detached.", :lib-source "com.blockether.spel.frame/is-detached?"} {:ns "frame", :name "locator", :arglists "[frame selector]", :doc "Creates a Locator for the frame.", :lib-source "com.blockether.spel.frame/frame-locator"} {:ns "frame", :name "name", :arglists "[frame]", :doc "Returns the frame name.", :lib-source "com.blockether.spel.frame/frame-name"} {:ns "frame", :name "navigate", :arglists "[frame url] | [frame url nav-opts]", :doc "Navigates the frame to a URL.", :lib-source "com.blockether.spel.frame/frame-navigate"} {:ns "frame", :name "parent-frame", :arglists "[frame]", :doc "Returns the parent frame.", :lib-source "com.blockether.spel.frame/parent-frame"} {:ns "frame", :name "set-content!", :arglists "[frame html] | [frame html set-opts]", :doc "Sets the HTML content of the frame.", :lib-source "com.blockether.spel.frame/frame-set-content!"} {:ns "frame", :name "title", :arglists "[frame]", :doc "Returns the frame title.", :lib-source "com.blockether.spel.frame/frame-title"} {:ns "frame", :name "url", :arglists "[frame]", :doc "Returns the frame URL.", :lib-source "com.blockether.spel.frame/frame-url"} {:ns "frame", :name "wait-for-function", :arglists "[frame expression]", :doc "Waits for a JavaScript function to return truthy in the frame.", :lib-source "com.blockether.spel.frame/frame-wait-for-function"} {:ns "frame", :name "wait-for-load-state", :arglists "[frame] | [frame state]", :doc "Waits for the frame to reach a load state.", :lib-source "com.blockether.spel.frame/frame-wait-for-load-state"} {:ns "frame", :name "wait-for-selector", :arglists "[frame selector] | [frame selector wait-opts]", :doc "Waits for a selector in the frame.", :lib-source "com.blockether.spel.frame/frame-wait-for-selector"} {:ns "net", :name "request-all-headers", :arglists "[req]", :doc "Returns all request headers including redirects.", :lib-source "com.blockether.spel.network/request-all-headers"} {:ns "net", :name "request-failure", :arglists "[req]", :doc "Returns the failure text if the request failed.", :lib-source "com.blockether.spel.network/request-failure"} {:ns "net", :name "request-frame", :arglists "[req]", :doc "Returns the frame that initiated this request.", :lib-source "com.blockether.spel.network/request-frame"} {:ns "net", :name "request-headers", :arglists "[req]", :doc "Returns the request headers as a map.", :lib-source "com.blockether.spel.network/request-headers"} {:ns "net", :name "request-is-navigation?", :arglists "[req]", :doc "Returns whether this is a navigation request.", :lib-source "com.blockether.spel.network/request-is-navigation?"} {:ns "net", :name "request-method", :arglists "[req]", :doc "Returns the request HTTP method.", :lib-source "com.blockether.spel.network/request-method"} {:ns "net", :name "request-post-data", :arglists "[req]", :doc "Returns the request POST data.", :lib-source "com.blockether.spel.network/request-post-data"} {:ns "net", :name "request-post-data-buffer", :arglists "[req]", :doc "Returns the request POST data as bytes.", :lib-source "com.blockether.spel.network/request-post-data-buffer"} {:ns "net", :name "request-redirected-from", :arglists "[req]", :doc "Returns the request that redirected to this one.", :lib-source "com.blockether.spel.network/request-redirected-from"} {:ns "net", :name "request-redirected-to", :arglists "[req]", :doc "Returns the request this was redirected to.", :lib-source "com.blockether.spel.network/request-redirected-to"} {:ns "net", :name "request-resource-type", :arglists "[req]", :doc "Returns the resource type (e.g. document, script, image).", :lib-source "com.blockether.spel.network/request-resource-type"} {:ns "net", :name "request-response", :arglists "[req]", :doc "Returns the response for this request.", :lib-source "com.blockether.spel.network/request-response"} {:ns "net", :name "request-timing", :arglists "[req]", :doc "Returns the request timing information.", :lib-source "com.blockether.spel.network/request-timing"} {:ns "net", :name "request-url", :arglists "[req]", :doc "Returns the request URL.", :lib-source "com.blockether.spel.network/request-url"} {:ns "net", :name "response-all-headers", :arglists "[resp]", :doc "Returns all response headers.", :lib-source "com.blockether.spel.network/response-all-headers"} {:ns "net", :name "response-body", :arglists "[resp]", :doc "Returns the response body as bytes.", :lib-source "com.blockether.spel.network/response-body"} {:ns "net", :name "response-finished", :arglists "[resp]", :doc "Returns nil when response finishes, or the failure error string.", :lib-source "com.blockether.spel.network/response-finished"} {:ns "net", :name "response-frame", :arglists "[resp]", :doc "Returns the frame that received this response.", :lib-source "com.blockether.spel.network/response-frame"} {:ns "net", :name "response-header-value", :arglists "[resp name]", :doc "Returns the value of a specific header.", :lib-source "com.blockether.spel.network/response-header-value"} {:ns "net", :name "response-header-values", :arglists "[resp name]", :doc "Returns all values for a specific header.", :lib-source "com.blockether.spel.network/response-header-values"} {:ns "net", :name "response-headers", :arglists "[resp]", :doc "Returns the response headers.", :lib-source "com.blockether.spel.network/response-headers"} {:ns "net", :name "response-ok?", :arglists "[resp]", :doc "Returns whether the response status is 2xx.", :lib-source "com.blockether.spel.network/response-ok?"} {:ns "net", :name "response-request", :arglists "[resp]", :doc "Returns the request for this response.", :lib-source "com.blockether.spel.network/response-request"} {:ns "net", :name "response-status", :arglists "[resp]", :doc "Returns the HTTP status code.", :lib-source "com.blockether.spel.network/response-status"} {:ns "net", :name "response-status-text", :arglists "[resp]", :doc "Returns the HTTP status text.", :lib-source "com.blockether.spel.network/response-status-text"} {:ns "net", :name "response-text", :arglists "[resp]", :doc "Returns the response body as text.", :lib-source "com.blockether.spel.network/response-text"} {:ns "net", :name "response-url", :arglists "[resp]", :doc "Returns the response URL.", :lib-source "com.blockether.spel.network/response-url"} {:ns "net", :name "route-abort!", :arglists "[route] | [route error-code]", :doc "Aborts the route.", :lib-source "com.blockether.spel.network/route-abort!"} {:ns "net", :name "route-continue!", :arglists "[route] | [route opts]", :doc "Continues the route, optionally modifying the request.", :lib-source "com.blockether.spel.network/route-continue!"} {:ns "net", :name "route-fallback!", :arglists "[route]", :doc "Falls through to the next route handler.", :lib-source "com.blockether.spel.network/route-fallback!"} {:ns "net", :name "route-fetch!", :arglists "[route]", :doc "Performs the request and returns the response.", :lib-source "com.blockether.spel.network/route-fetch!"} {:ns "net", :name "route-fulfill!", :arglists "[route opts]", :doc "Fulfills the route with a custom response.", :lib-source "com.blockether.spel.network/route-fulfill!"} {:ns "net", :name "route-request", :arglists "[route]", :doc "Returns the request being routed.", :lib-source "com.blockether.spel.network/route-request"} {:ns "net", :name "ws-is-closed?", :arglists "[ws]", :doc "Returns whether the WebSocket is closed.", :lib-source "com.blockether.spel.network/ws-is-closed?"} {:ns "net", :name "ws-on-close", :arglists "[ws handler]", :doc "Registers a handler for WebSocket close.", :lib-source "com.blockether.spel.network/ws-on-close"} {:ns "net", :name "ws-on-error", :arglists "[ws handler]", :doc "Registers a handler for WebSocket errors.", :lib-source "com.blockether.spel.network/ws-on-error"} {:ns "net", :name "ws-on-message", :arglists "[ws handler]", :doc "Registers a handler for incoming messages.", :lib-source "com.blockether.spel.network/ws-on-message"} {:ns "net", :name "ws-url", :arglists "[ws]", :doc "Returns the WebSocket URL.", :lib-source "com.blockether.spel.network/ws-url"} {:ns "net", :name "wsf-binary", :arglists "[frame]", :doc "Returns the binary content of a WebSocket frame.", :lib-source "com.blockether.spel.network/wsf-binary"} {:ns "net", :name "wsf-text", :arglists "[frame]", :doc "Returns the text content of a WebSocket frame.", :lib-source "com.blockether.spel.network/wsf-text"} {:ns "net", :name "wsr-close!", :arglists "[wsr]", :doc "Closes the WebSocket connection from the server side.", :lib-source "com.blockether.spel.network/wsr-close!"} {:ns "net", :name "wsr-connect-to-server!", :arglists "[wsr]", :doc "Connects to the real server WebSocket.", :lib-source "com.blockether.spel.network/wsr-connect-to-server!"} {:ns "net", :name "wsr-on-close", :arglists "[wsr handler]", :doc "Registers a handler for close events.", :lib-source "com.blockether.spel.network/wsr-on-close"} {:ns "net", :name "wsr-on-message", :arglists "[wsr handler]", :doc "Registers a handler for client messages on the route.", :lib-source "com.blockether.spel.network/wsr-on-message"} {:ns "net", :name "wsr-send!", :arglists "[wsr message]", :doc "Sends a message to the client.", :lib-source "com.blockether.spel.network/wsr-send!"} {:ns "net", :name "wsr-url", :arglists "[wsr]", :doc "Returns the URL of a WebSocketRoute.", :lib-source "com.blockether.spel.network/wsr-url"} {:ns "loc", :name "all", :arglists "[loc]", :doc "Returns all elements matching the locator as individual locators.", :lib-source "com.blockether.spel.locator/all"} {:ns "loc", :name "all-inner-texts", :arglists "[loc]", :doc "Returns all inner texts for matching elements.", :lib-source "com.blockether.spel.locator/all-inner-texts"} {:ns "loc", :name "all-text-contents", :arglists "[loc]", :doc "Returns all text contents for matching elements.", :lib-source "com.blockether.spel.locator/all-text-contents"} {:ns "loc", :name "blur", :arglists "[loc]", :doc "Blurs (removes focus from) the element.", :lib-source "com.blockether.spel.locator/blur"} {:ns "loc", :name "bounding-box", :arglists "[loc]", :doc "Returns the bounding box of the element.", :lib-source "com.blockether.spel.locator/bounding-box"} {:ns "loc", :name "check", :arglists "[loc] | [loc check-opts]", :doc "Checks a checkbox or radio button.", :lib-source "com.blockether.spel.locator/check"} {:ns "loc", :name "clear", :arglists "[loc]", :doc "Clears input field content.", :lib-source "com.blockether.spel.locator/clear"} {:ns "loc", :name "click", :arglists "[loc] | [loc click-opts]", :doc "Clicks an element.", :lib-source "com.blockether.spel.locator/click"} {:ns "loc", :name "content-frame", :arglists "[loc]", :doc "Returns a FrameLocator pointing to the same iframe as this locator.", :lib-source "com.blockether.spel.locator/content-frame"} {:ns "loc", :name "count-elements", :arglists "[loc]", :doc "Returns the number of elements matching the locator.", :lib-source "com.blockether.spel.locator/count-elements"} {:ns "loc", :name "dblclick", :arglists "[loc] | [loc dblclick-opts]", :doc "Double-clicks an element.", :lib-source "com.blockether.spel.locator/dblclick"} {:ns "loc", :name "dispatch-event", :arglists "[loc type]", :doc "Dispatches a DOM event on the element.", :lib-source "com.blockether.spel.locator/dispatch-event"} {:ns "loc", :name "drag-to", :arglists "[loc target]", :doc "Drags this locator to another locator.", :lib-source "com.blockether.spel.locator/drag-to"} {:ns "loc", :name "element-handle", :arglists "[loc]", :doc "Returns the ElementHandle for the first matching element.", :lib-source "com.blockether.spel.locator/element-handle"} {:ns "loc", :name "element-handles", :arglists "[loc]", :doc "Returns all ElementHandles matching the locator.", :lib-source "com.blockether.spel.locator/element-handles"} {:ns "loc", :name "evaluate", :arglists "[loc expression] | [loc expression arg]", :doc "Evaluates JavaScript on the element found by this locator.", :lib-source "com.blockether.spel.locator/evaluate-locator"} {:ns "loc", :name "evaluate-all", :arglists "[loc expression] | [loc expression arg]", :doc "Evaluates JavaScript on all elements matching the locator.", :lib-source "com.blockether.spel.locator/evaluate-all"} {:ns "loc", :name "fill", :arglists "[loc value] | [loc value fill-opts]", :doc "Fills an input element with text.", :lib-source "com.blockether.spel.locator/fill"} {:ns "loc", :name "first-element", :arglists "[loc]", :doc "Returns the first element matching the locator.", :lib-source "com.blockether.spel.locator/first-element"} {:ns "loc", :name "focus", :arglists "[loc]", :doc "Focuses the element.", :lib-source "com.blockether.spel.locator/focus"} {:ns "loc", :name "get-attribute", :arglists "[loc name]", :doc "Returns the value of an attribute.", :lib-source "com.blockether.spel.locator/get-attribute"} {:ns "loc", :name "highlight", :arglists "[loc]", :doc "Highlights the element for debugging.", :lib-source "com.blockether.spel.locator/highlight"} {:ns "loc", :name "hover", :arglists "[loc] | [loc hover-opts]", :doc "Hovers over an element.", :lib-source "com.blockether.spel.locator/hover"} {:ns "loc", :name "inner-html", :arglists "[loc]", :doc "Returns the inner HTML of the element.", :lib-source "com.blockether.spel.locator/inner-html"} {:ns "loc", :name "inner-text", :arglists "[loc]", :doc "Returns the inner text of the element.", :lib-source "com.blockether.spel.locator/inner-text"} {:ns "loc", :name "input-value", :arglists "[loc]", :doc "Returns the input value of an input element.", :lib-source "com.blockether.spel.locator/input-value"} {:ns "loc", :name "is-checked?", :arglists "[loc]", :doc "Returns whether the element is checked.", :lib-source "com.blockether.spel.locator/is-checked?"} {:ns "loc", :name "is-disabled?", :arglists "[loc]", :doc "Returns whether the element is disabled.", :lib-source "com.blockether.spel.locator/is-disabled?"} {:ns "loc", :name "is-editable?", :arglists "[loc]", :doc "Returns whether the element is editable.", :lib-source "com.blockether.spel.locator/is-editable?"} {:ns "loc", :name "is-enabled?", :arglists "[loc]", :doc "Returns whether the element is enabled.", :lib-source "com.blockether.spel.locator/is-enabled?"} {:ns "loc", :name "is-hidden?", :arglists "[loc]", :doc "Returns whether the element is hidden.", :lib-source "com.blockether.spel.locator/is-hidden?"} {:ns "loc", :name "is-visible?", :arglists "[loc]", :doc "Returns whether the element is visible.", :lib-source "com.blockether.spel.locator/is-visible?"} {:ns "loc", :name "last-element", :arglists "[loc]", :doc "Returns the last element matching the locator.", :lib-source "com.blockether.spel.locator/last-element"} {:ns "loc", :name "loc-filter", :arglists "[loc opts]", :doc "Filters this locator to a narrower set.", :lib-source "com.blockether.spel.locator/loc-filter"} {:ns "loc", :name "loc-get-by-label", :arglists "[loc text]", :doc "Locates elements by label within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-label"} {:ns "loc", :name "loc-get-by-role", :arglists "[loc role]", :doc "Locates elements by ARIA role within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-role"} {:ns "loc", :name "loc-get-by-test-id", :arglists "[loc test-id]", :doc "Locates elements by test ID within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-test-id"} {:ns "loc", :name "loc-get-by-text", :arglists "[loc text]", :doc "Locates elements by text within this locator.", :lib-source "com.blockether.spel.locator/loc-get-by-text"} {:ns "loc", :name "loc-locator", :arglists "[loc selector]", :doc "Creates a sub-locator within this locator.", :lib-source "com.blockether.spel.locator/loc-locator"} {:ns "loc", :name "nth-element", :arglists "[loc index]", :doc "Returns the nth element matching the locator.", :lib-source "com.blockether.spel.locator/nth-element"} {:ns "loc", :name "press", :arglists "[loc key] | [loc key press-opts]", :doc "Presses a key or key combination.", :lib-source "com.blockether.spel.locator/press"} {:ns "loc", :name "screenshot", :arglists "[loc] | [loc ss-opts]", :doc "Takes a screenshot of the element.", :lib-source "com.blockether.spel.locator/locator-screenshot"} {:ns "loc", :name "scroll-into-view", :arglists "[loc]", :doc "Scrolls element into view.", :lib-source "com.blockether.spel.locator/scroll-into-view"} {:ns "loc", :name "select-option", :arglists "[loc values]", :doc "Selects options in a select element.", :lib-source "com.blockether.spel.locator/select-option"} {:ns "loc", :name "set-input-files!", :arglists "[loc files]", :doc "Sets the value of a file input element.", :lib-source "com.blockether.spel.locator/set-input-files!"} {:ns "loc", :name "tap-element", :arglists "[loc]", :doc "Taps an element (for touch devices).", :lib-source "com.blockether.spel.locator/tap-element"} {:ns "loc", :name "text-content", :arglists "[loc]", :doc "Returns the text content of the element.", :lib-source "com.blockether.spel.locator/text-content"} {:ns "loc", :name "type-text", :arglists "[loc text] | [loc text type-opts]", :doc "Types text into an element character by character.", :lib-source "com.blockether.spel.locator/type-text"} {:ns "loc", :name "uncheck", :arglists "[loc] | [loc uncheck-opts]", :doc "Unchecks a checkbox.", :lib-source "com.blockether.spel.locator/uncheck"} {:ns "loc", :name "wait-for", :arglists "[loc] | [loc wait-opts]", :doc "Waits for the locator to satisfy a condition.", :lib-source "com.blockether.spel.locator/wait-for"} {:ns "assert", :name "api-not", :arglists "[ara]", :doc "Returns negated APIResponseAssertions (expect the opposite).", :lib-source "com.blockether.spel.assertions/api-not"} {:ns "assert", :name "assert-that", :arglists "[target]", :doc "Creates an assertion object for the given Playwright instance.", :lib-source "com.blockether.spel.assertions/assert-that"} {:ns "assert", :name "contains-class", :arglists "[la class-val] | [la class-val opts]", :doc "Asserts the locator's class attribute contains the specified class.", :lib-source "com.blockether.spel.assertions/contains-class"} {:ns "assert", :name "contains-text", :arglists "[la text] | [la text opts]", :doc "Asserts the locator contains the specified text.", :lib-source "com.blockether.spel.assertions/contains-text"} {:ns "assert", :name "has-accessible-description", :arglists "[la desc]", :doc "Asserts the locator has the specified accessible description.", :lib-source "com.blockether.spel.assertions/has-accessible-description"} {:ns "assert", :name "has-accessible-error-message", :arglists "[la msg]", :doc "Asserts the locator has the specified accessible error message.", :lib-source "com.blockether.spel.assertions/has-accessible-error-message"} {:ns "assert", :name "has-accessible-name", :arglists "[la name-val]", :doc "Asserts the locator has the specified accessible name.", :lib-source "com.blockether.spel.assertions/has-accessible-name"} {:ns "assert", :name "has-attribute", :arglists "[la name value] | [la name value opts]", :doc "Asserts the locator has the specified attribute with value.", :lib-source "com.blockether.spel.assertions/has-attribute"} {:ns "assert", :name "has-class", :arglists "[la class-val] | [la class-val opts]", :doc "Asserts the locator has the specified CSS class.", :lib-source "com.blockether.spel.assertions/has-class"} {:ns "assert", :name "has-count", :arglists "[la count] | [la count opts]", :doc "Asserts the locator resolves to the expected number of elements.", :lib-source "com.blockether.spel.assertions/has-count"} {:ns "assert", :name "has-css", :arglists "[la name value] | [la name value opts]", :doc "Asserts the locator has the specified CSS property with value.", :lib-source "com.blockether.spel.assertions/has-css"} {:ns "assert", :name "has-id", :arglists "[la id] | [la id opts]", :doc "Asserts the locator has the specified ID.", :lib-source "com.blockether.spel.assertions/has-id"} {:ns "assert", :name "has-js-property", :arglists "[la name value]", :doc "Asserts the locator has the specified JavaScript property.", :lib-source "com.blockether.spel.assertions/has-js-property"} {:ns "assert", :name "has-role", :arglists "[la role]", :doc "Asserts the locator has the specified ARIA role.", :lib-source "com.blockether.spel.assertions/has-role"} {:ns "assert", :name "has-text", :arglists "[la text] | [la text opts]", :doc "Asserts the locator has the specified text.", :lib-source "com.blockether.spel.assertions/has-text"} {:ns "assert", :name "has-title", :arglists "[pa title] | [pa title opts]", :doc "Asserts the page has the specified title.", :lib-source "com.blockether.spel.assertions/has-title"} {:ns "assert", :name "has-url", :arglists "[pa url] | [pa url opts]", :doc "Asserts the page has the specified URL.", :lib-source "com.blockether.spel.assertions/has-url"} {:ns "assert", :name "has-value", :arglists "[la value] | [la value opts]", :doc "Asserts the locator (input) has the specified value.", :lib-source "com.blockether.spel.assertions/has-value"} {:ns "assert", :name "has-values", :arglists "[la values] | [la values opts]", :doc "Asserts the locator (multi-select) has the specified values.", :lib-source "com.blockether.spel.assertions/has-values"} {:ns "assert", :name "is-attached", :arglists "[la] | [la opts]", :doc "Asserts the locator is attached to the DOM.", :lib-source "com.blockether.spel.assertions/is-attached"} {:ns "assert", :name "is-checked", :arglists "[la] | [la opts]", :doc "Asserts the locator (checkbox/radio) is checked.", :lib-source "com.blockether.spel.assertions/is-checked"} {:ns "assert", :name "is-disabled", :arglists "[la] | [la opts]", :doc "Asserts the locator is disabled.", :lib-source "com.blockether.spel.assertions/is-disabled"} {:ns "assert", :name "is-editable", :arglists "[la] | [la opts]", :doc "Asserts the locator is editable.", :lib-source "com.blockether.spel.assertions/is-editable"} {:ns "assert", :name "is-empty", :arglists "[la]", :doc "Asserts the locator (input) is empty.", :lib-source "com.blockether.spel.assertions/is-empty"} {:ns "assert", :name "is-enabled", :arglists "[la] | [la opts]", :doc "Asserts the locator is enabled.", :lib-source "com.blockether.spel.assertions/is-enabled"} {:ns "assert", :name "is-focused", :arglists "[la] | [la opts]", :doc "Asserts the locator is focused.", :lib-source "com.blockether.spel.assertions/is-focused"} {:ns "assert", :name "is-hidden", :arglists "[la] | [la opts]", :doc "Asserts the locator is hidden.", :lib-source "com.blockether.spel.assertions/is-hidden"} {:ns "assert", :name "is-in-viewport", :arglists "[la] | [la opts]", :doc "Asserts the locator is in the viewport.", :lib-source "com.blockether.spel.assertions/is-in-viewport"} {:ns "assert", :name "is-ok", :arglists "[ara]", :doc "Asserts the API response status is 2xx.", :lib-source "com.blockether.spel.assertions/is-ok"} {:ns "assert", :name "is-visible", :arglists "[la] | [la opts]", :doc "Asserts the locator is visible.", :lib-source "com.blockether.spel.assertions/is-visible"} {:ns "assert", :name "loc-not", :arglists "[la]", :doc "Returns negated LocatorAssertions (expect the opposite).", :lib-source "com.blockether.spel.assertions/loc-not"} {:ns "assert", :name "matches-aria-snapshot", :arglists "[la snapshot]", :doc "Asserts the locator matches the ARIA snapshot.", :lib-source "com.blockether.spel.assertions/matches-aria-snapshot"} {:ns "assert", :name "page-not", :arglists "[pa]", :doc "Returns negated PageAssertions (expect the opposite).", :lib-source "com.blockether.spel.assertions/page-not"} {:ns "assert", :name "set-default-assertion-timeout!", :arglists "[timeout]", :doc "Sets the default timeout for all assertions.", :lib-source "com.blockether.spel.assertions/set-default-assertion-timeout!"} {:ns "core", :name "anomaly?", :arglists "", :doc "Returns true if x is an anomaly map (has a recognized anomaly category).", :lib-source "com.blockether.spel.core/anomaly?"} {:ns "core", :name "browser-connected?", :arglists "[browser]", :doc "Returns true if the browser is connected.", :lib-source "com.blockether.spel.core/browser-connected?"} {:ns "core", :name "browser-contexts", :arglists "[browser]", :doc "Returns all browser contexts.", :lib-source "com.blockether.spel.core/browser-contexts"} {:ns "core", :name "browser-version", :arglists "[browser]", :doc "Returns the browser version string.", :lib-source "com.blockether.spel.core/browser-version"} {:ns "core", :name "close!", :arglists "[pw]", :doc "Closes a Playwright instance and releases all resources.", :lib-source "com.blockether.spel.core/close!"} {:ns "core", :name "close-browser!", :arglists "[browser]", :doc "Closes a browser and all its pages.", :lib-source "com.blockether.spel.core/close-browser!"} {:ns "core", :name "close-context!", :arglists "[context]", :doc "Closes a browser context and all its pages.", :lib-source "com.blockether.spel.core/close-context!"} {:ns "core", :name "close-page!", :arglists "[page]", :doc "Closes a page.", :lib-source "com.blockether.spel.core/close-page!"} {:ns "core", :name "context-browser", :arglists "[context]", :doc "Returns the browser that owns this context.", :lib-source "com.blockether.spel.core/context-browser"} {:ns "core", :name "context-clear-cookies!", :arglists "[context]", :doc "Clears all cookies in the context.", :lib-source "com.blockether.spel.core/context-clear-cookies!"} {:ns "core", :name "context-clear-permissions!", :arglists "[context]", :doc "Clears all granted permissions.", :lib-source "com.blockether.spel.core/context-clear-permissions!"} {:ns "core", :name "context-cookies", :arglists "[context]", :doc "Returns all cookies in the context.", :lib-source "com.blockether.spel.core/context-cookies"} {:ns "core", :name "context-grant-permissions!", :arglists "[context permissions]", :doc "Grants permissions to the context.", :lib-source "com.blockether.spel.core/context-grant-permissions!"} {:ns "core", :name "context-pages", :arglists "[context]", :doc "Returns all pages in a context.", :lib-source "com.blockether.spel.core/context-pages"} {:ns "core", :name "context-route-from-har!", :arglists "[context har] | [context har route-opts]", :doc "Routes requests in the context from a HAR file. Replays recorded responses", :lib-source "com.blockether.spel.core/context-route-from-har!"} {:ns "core", :name "context-route-web-socket!", :arglists "[context pattern handler]", :doc "Registers a handler for WebSocket connections matching a URL pattern", :lib-source "com.blockether.spel.core/context-route-web-socket!"} {:ns "core", :name "context-save-storage-state!", :arglists "[context path]", :doc "Saves the storage state (cookies, localStorage) to a file.", :lib-source "com.blockether.spel.core/context-save-storage-state!"} {:ns "core", :name "context-set-default-navigation-timeout!", :arglists "[context timeout]", :doc "Sets the default navigation timeout.", :lib-source "com.blockether.spel.core/context-set-default-navigation-timeout!"} {:ns "core", :name "context-set-default-timeout!", :arglists "[context timeout]", :doc "Sets the default timeout for context operations.", :lib-source "com.blockether.spel.core/context-set-default-timeout!"} {:ns "core", :name "context-set-extra-http-headers!", :arglists "[context headers]", :doc "Sets extra HTTP headers for all requests in the context.", :lib-source "com.blockether.spel.core/context-set-extra-http-headers!"} {:ns "core", :name "context-set-offline!", :arglists "[context offline]", :doc "Sets the context to offline or online mode.", :lib-source "com.blockether.spel.core/context-set-offline!"} {:ns "core", :name "context-storage-state", :arglists "[context]", :doc "Returns the storage state (cookies, localStorage) as a JSON string.", :lib-source "com.blockether.spel.core/context-storage-state"}]